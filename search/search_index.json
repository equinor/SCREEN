{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The Script-based Risk Estimation of well leakage in Early phase evaluatioN (SCREEN) project targets legacy well assessment for Carbon Capture and Storage (CCS) projects. Given that abandoned or inactive wells can serve as pathways for CO2 leakage, rigorous risk assessments and integrity evaluations are crucial [1; 2].</p> <p>Within the SCREEN project, the process of evaluating legacy wells involves multiple steps made by different disciplines using various tools. From the identification of legacy wells to the quantification of leakage, several tasks are carried out that involve data gathering, data processing, and both qualitative and quantitative analysis (Figure 1.1). The contents of this repository, and the main delivery of the SCREEN project, consist of two components that aim to streamline analysis in legacy well evaluations, improving data processing and analysis for well integrity engineers and subsurface teams.</p> <p>In this repository, SCREEN has delivered scripts to facilitate mainly two steps of the generalized workflow displayed in Figure 1.1. Within the pre-processing and preliminary assessment module, we have built a script for processing data so it is ready to be used in the detailed simulation workflow using the CIRRUS (formerly known as PFLOTRAN-OGS) tool. The preliminary assessments apply to all legacy wells, contingent on data availability; this component has migrated and is now part of the functionalities offered by the WINC tool. The output of that step shall serve as a basis for any risk assessment, barrier evaluation, and other analyses done on WINC. In case the well is identified as one that presents a risk of leakage, the same output serves as a basis to use the scripts of this repository to build a simulation model that facilitates the quantification of leakage rates.</p> <p>While the simulation workflow includes modeling of key well integrity risks, it is not comprehensive for scenarios like material degradation or overburden fracturing. Specialists must assess these risks using different tools. For overburden leakage risks, a REVEAL-based workflow, stemming from SCREEN, is recommended (Figure 1.1).</p> <p></p>"},{"location":"#data-preparation","title":"Data Preparation","text":"<p>Data preparation is a prerequisite for employing SCREEN workflows. Before the user embarks on using the SCREEN scripts, they should have gathered wellbore and subsurface data necessary for subsequent analysis.</p>"},{"location":"#required-data-types-for-legacy-well-analyses","title":"Required Data Types for Legacy Well Analyses","text":"<ul> <li>Well Headers: </li> <li> <p>Data such as well location, type, time of abandonment, and water depth.</p> </li> <li> <p>Well Construction Details: </p> </li> <li> <p>Information on drilling, completion, and abandonment processes, including borehole sizes, casings, and cement records.</p> </li> <li> <p>Subsurface Information: </p> </li> <li> <p>Geological data, including lithology and formation tests, required to identify potential barriers and flow paths.</p> </li> <li> <p>Assumed Parameters: </p> </li> <li>Estimates for parameters such as reservoir fluid composition, geothermal gradient, overburden strength, and CO2 column size or CO2-water contact depth, in the absence of direct measurements.</li> </ul> <p>Data can originate from databases such as SMDA and Wellcom, but it is the users' responsibility to input this data into SCREEN workflows manually or via other applications. Notably, the implementation within the WINC platform automates data retrieval from databases prior to running the SCREEN modules (Figure 1.2).</p> <p>For clarification, SCREEN workflows do not interact with databases directly but rely on user-provided data, manually entered or sourced from other systems.</p> <p></p>"},{"location":"#references","title":"References","text":"<ol> <li>ISO. (2017). ISO 27914:2017 Carbon dioxide capture, transportation and geological storage \u2014 Geological storage. Retrieved from ISO 27914:2017</li> <li>DNV. (2019). DNV-RP-J203 Geological storage of carbon dioxide. Retrieved from DNV-RP-J203</li> </ol>"},{"location":"INSTALLATION/","title":"SCREEN","text":"<p>This repository contains source codes and documentation for SCREEN project.</p> <p> </p>"},{"location":"INSTALLATION/#clone-the-repository","title":"Clone the repository","text":"<p>Locate a folder at your local machine that you intend to investigate the codes, and then clone the repository <pre><code>git clone https://github.com/equinor/SCREEN</code></pre> By this time you should have a folder named <code>SCREEN</code> at your local machine. Now change the directory with linux command: <pre><code>cd SCREEN</code></pre></p> <p>It's normal for us to make a new branch if we indend to make some changes of the codes. This can be done with the <code>-b</code> option, for example: <pre><code>git checkout -b xyz/cleanup</code></pre> This would generate a new branch, named <code>xyz/cleanup</code>. Here the branch name is created by concatenating a short name, such as <code>xyz</code>,  of <code>equinor</code> account with a feature description <code>cleanup</code>. There is no need to follow this convention. You could simply pick any branch name as long as it makes sense. However, please note branch names have limitations.</p>"},{"location":"INSTALLATION/#virtual-environment","title":"Virtual environment","text":"<p>It's a common practice to work on a project within a python virtual environment. I have been using python's builtin module <code>venv</code> for a long while. So I am going to stick to it here as an example to set up the virtual environment. But you are free to use any other virtual environment setups that you feel comfortable with, such as <code>conda</code>, etc.  <pre><code>python -m venv venv_screen</code></pre> This will build a virtual environment <code>venv_screen</code>. You only need to creat it once.</p> <p>To activate this <code>venv_screen</code>, run the following command:  <pre><code>source venv_screen/bin/activate.csh</code></pre> when your linux Shell is <code>csh</code>. </p> <p>If you are using <code>bash</code> or plain <code>sh</code>, you can activate it with the following command: <pre><code>source venv_screen/bin/activate</code></pre></p> <p>We pack needed python packages into a file, such as <code>requirements.txt</code>. And install those python packages to this virtual environment by running the following command: <pre><code>pip install -r requirements.txt</code></pre> You should now be ready to play with the source codes.</p>"},{"location":"INSTALLATION/#poetry-for-dependency-management","title":"Poetry for dependency management","text":"<p><code>poetry</code>, as an alternative tool for dependency management, is required in Equinor to be compliant with IT policy.</p>"},{"location":"INSTALLATION/#1-installation-of-poetry","title":"1. Installation of poetry","text":"<p>In case that <code>poetry</code> is not available in the system, you may have to download and install it yourself. Somehow the newer version of <code>poetry</code> doesn't work with python <code>3.8</code>. So we have to get an earlier of <code>poetry</code>, such as <code>1.2.0</code> with the following command:  <pre><code>curl -sSL https://install.python-poetry.org | python3 - --version 1.2.0</code></pre> This should install <code>poetry</code> in your home directory. For example, in my case, it is installed at <code>/private/hzh/.local/bin</code>. Make sure to set this path as an environment variable in your <code>.cshrc</code> or <code>.bashrc</code> file so that you can access <code>poetry</code> from anywhere.</p> <p>You can test that everything is set up by executing:</p> <pre><code>poetry --version</code></pre>"},{"location":"INSTALLATION/#2-installation-of-python-dependencies","title":"2. Installation of python dependencies","text":"<p>To install python dependencies, run the following command*: <pre><code>poetry install</code></pre></p> <p>To check what packages have been installed, try the following command: <pre><code>poetry show --tree</code></pre></p> <p>To show where the virtual environment is located, run <pre><code>poetry env info</code></pre> This will display the python path for the activated virtual environment. The executable path can be used in VS Code to set up python interpreter path for builtin jupyter notebooks.</p> <p>The virtual envrionment can be activated with the command*: <pre><code>poetry shell</code></pre> This generated shell will be used to run standalone python scripts.</p> <p>Note: For whatever reason, in case you decide to uninstall <code>poetry</code> package, you can do it with <pre><code>curl -sSL https://install.python-poetry.org | python3 - --uninstall</code></pre></p>"},{"location":"INSTALLATION/#experiments","title":"Experiments","text":"<p>There are at least two ways to make experimenal runs of the codes. One is to run the experiments with Jupyter lab, and the other is commandline option. While Jupyter notebooks are mainly for QC tests and research purposes, the commandline option is aiming for production run.</p>"},{"location":"INSTALLATION/#1-jupyter-notebooks","title":"1. Jupyter notebooks","text":"<p>Jupyter notebooks are located in directory <code>notebooks</code>. To test its functionaries, change current directory to <code>notebooks</code> and launch jupyter notebooks at the commandline: <pre><code>jupyter-lab</code></pre> Or if you prefer, you can run these Jupyter notebooks from Microsoft's VS code.</p> <p>There exist several Jupyter notebooks in the directory:</p> <ul> <li>Notebook GaP-WellClass.ipynb is a test example for the integration of <code>GaP</code> and <code>WellClass</code>. It hides many details. It require eclipse <code>.EGRID</code> and <code>.INIT</code> as input files. This notebook also serves the role of generating <code>pytest</code> data for unit testing.</li> <li>Notebook pflotran-gap.ipynb integrates <code>GaP</code> and <code>WellClass</code> too. But instead of the user-provided <code>.EGRID</code> and <code>.INIT</code> files, both files are generates by calling pflotran scripts.</li> <li>Notebook Pressure-WellClass_test.ipynb is Alejandro's tests on deviated wells.</li> <li>Notebook Pressure-WellClass.ipynb is used to test pressure. </li> <li>Notebook WellClass_csv_yaml.ipynb is used to test pressure and loading <code>.csv</code> and <code>.yaml</code> input files.</li> </ul>"},{"location":"INSTALLATION/#2-commandline-option","title":"2. Commandline option","text":"<p>Two python scripts for commandline option are available in directory <code>experiments</code>. One script, gap_plotran.py, can be used not only for generating Eclipse <code>.EGRID</code> and <code>.INIT</code> on the fly but also can be used for quick <code>pflotran</code> test, while the other script, gap_wellclass.py, requires the user to provide these two grid files.  </p> <p>The followings are some of  the sample runs. In either way, you should run the python script inside the <code>SCREEN</code> directory. </p> <ol> <li> <p>To test gap_wellclass.py, run either of the followings: <pre><code># 1. for smeaheia_v1\n\npython -m experiments.gap_wellclass --sim-path ./test_data/examples/smeaheia_v1 --well smeaheia.yaml --sim-case GEN_NOLGR_PH2 --plot \n\n# 2. for smeaheia_v2\n\npython -m experiments.gap_wellclass --sim-path ./test_data/examples/smeaheia_v2 --well smeaheia.yaml --sim-case TEMP-0 --plot\n\n# 3. for wildcat\n\npython -m experiments.gap_wellclass --sim-path ./test_data/examples/wildcat --well wildcat.yaml --sim-case TEMP-0 --plot\n</code></pre> This will generate an output file <code>LEG_HIRES.grdecl</code> in <code>experiments</code> directory.</p> </li> <li> <p>To test gap_plotran.py, run the following commnad at the directory <code>SCREEN</code>: <pre><code>python -m experiments.gap_pflotran \\\n    --sim-path ./test_data/examples/wildcat-pflotran \\\n    --well wildcat.yaml \\\n    --sim-case1 TEMP-0_NOSIM \\\n    --sim-case2 TEMP-0 \\\n    --plot</code></pre></p> </li> </ol>"},{"location":"INSTALLATION/#3-test-data","title":"3. Test data","text":"<p>In order for a quick test of the codes, we include some test dataset in the folder <code>test_data/examples</code>. The input data structure is organized  similiar to the <code>pflotran</code>. For example, for test data <code>test_data/examples/wildcat-pflotran-2</code>, the input file structure should be like this: <pre><code>\u251c\u2500\u2500 wildcat.yaml\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 co2_db_new.dat\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 temperature_gradient.inc\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TEMP_GRD.grdecl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 TEMP_GRD_NOSIM.grdecl\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tops_dz.inc\n\u2514\u2500\u2500 model\n    \u251c\u2500\u2500 TEMP-0.in\n    \u2514\u2500\u2500 TEMP-0_NOSIM.in</code></pre> Sub-directories, such as <code>wildcat</code>, <code>smeaheia_v1</code> and <code>smeaheia_v2</code>, contain the necessary data, e.g., Eclipse  <code>.EGRID</code> and <code>.INIT</code> files, for testing gap_wellclass.py. </p> <p>One sub-directory, <code>wildcat-plotran</code>, contains configuration parameters for testing gap_pflotran.py, i.e., use pfloatran to generate <code>.EGRID</code> and <code>.INIT</code>. </p> <p>Another sub-directory <code>frigg</code> contains information for testing deviated wells.</p> <p>In addition, the PVT values are included in the directory <code>pvt_contants</code> for self-consistent testing of pressure-related computes.</p>"},{"location":"INSTALLATION/#unit-testing-and-code-coverage","title":"Unit testing and code coverage","text":"<p>We are using <code>pytest</code> for unit testing and code coverage. The unit testing utilizes <code>wildcat</code> as the testing example. So please make sure the saved .pkl files in <code>test_data/examples/wildcat/pytest</code> exists and is updated. Here is a commandline example: <pre><code>python -m pytest tests</code></pre> This will report the unit testing results. And the following will report not only unit testing but also code coverage: <pre><code>python -m pytest --cov tests</code></pre> or a litle bit more complex command: <pre><code>python -m pytest --cov --cov-branch --cov-report term-missing tests</code></pre></p>"},{"location":"INSTALLATION/#documentation","title":"Documentation","text":"<p>The document can be automatically generated and deployed to github pages. To do that, type the following at the command line: <pre><code>mkdocs gh-deploy</code></pre> It may take some minutes until the documentation goes live. And the generated documentation page can be found at SCREEN docs.</p>"},{"location":"INSTALLATION/#the-code-structures","title":"The code structures","text":"<p>The following represents the current code structures:</p> <p><pre><code>\u251c\u2500\u2500 experiments\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 gap_pflotran.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 gap_wellclass.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 LEG_HIRES.grdecl\n\u251c\u2500\u2500 INSTALLATION.md\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 notebooks\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 GaP-WellClass.ipynb\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LEG_HIRES.grdecl.smeaheia\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 pflotran_gap.ipynb\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Pressure-WellClass.ipynb\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Pressure-WellClass_test.ipynb\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 WellClass_csv_yaml.ipynb\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 GaP\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 experiments\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 libs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 notebooks\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 PressCalc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 1D_PresCalc.ipynb\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 phase_envelope.png\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Pressure_plot.png\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PT_01012996\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PT_010153\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Readme.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 WellClass\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 libs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 notebooks\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 README.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 WellViz\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Readme.md\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 WellViz_Jan23_Dash_v4.py\n\u2514\u2500\u2500 test_data\n    \u251c\u2500\u2500 examples\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 wildcat\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 wildcat-pflotran\n    \u2502   \u251c\u2500\u2500 wildcat-pflotran-2\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 frigg\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 simple_well\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 smeaheia_v1\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 smeaheia_v2\n    \u2514\u2500\u2500 pvt_constants\n        \u251c\u2500\u2500 pressure.txt\n        \u251c\u2500\u2500 rho_co2.txt\n        \u251c\u2500\u2500 rho_h2o.txt\n        \u2514\u2500\u2500 temperature.txt</code></pre> It was generated with the linux command <code>tree</code>: <pre><code>tree -I 'docs|site|venv_screen|*pycache*|Equinor*|originals' -L 3</code></pre></p>"},{"location":"gap/","title":"Detailed Simulation workflow","text":"<p>To set up a CIRRUS (PFLOTRAN-OGS) simulation run, users must first complete the pre-processing and preliminary assessment phase, which involves creating Well and Pressure instances. These instances provide the necessary wellbore and pressure data for the simulation. Additionally, users need to have template CIRRUS input files that outline the simulation setup (TEMP-0.in) and the grid (TEMP_GRD.grdecl). These templates describe a basic \"shoebox\" model with a layer cake grid representing the vertical space from mean sea level to the reservoir, including the ocean water column and overburden rocks.</p> <p>The resulting simulation model is a 3D representation of the wellbore, with the well represented in a logically refined grid (LGR) at the center of the model. The zonation and assignment of transport properties in the model reflect the discrete sections of the well (cement bond, cement plugs, open hole). Casings are not discretely represented as grid cells but are modeled using transmissibility multipliers, which are set to zero by default to act as perfect barriers. The transport properties of the cement materials are assigned during the Well instance creation, while the properties of the reservoir and overburden rocks need to be manually set.</p> <p> Figure 1: Comparison of the template grid with updated overburden thickness (left) and the resulting grid after LGR generation (right).</p> <p>Users are encouraged to use the <code>wildcat-CIRRUS</code> dataset located in the <code>test_data/examples</code> folder, along with the <code>CIRRUS_gap</code> notebook or the <code>screen_well_to_gap.py</code> script. These resources guide users through library dependencies and path setups. The first step is to create copies of the template files and update them with well-specific information and problem setup details. This includes adjusting the thickness of overburden cells and updating equilibration information to initialize the simulation with expected reservoir pressure and temperature gradients.</p> <p>The equilibration is divided into two zones: 'overburden_water' for the brine in the overburden and ocean water column, and 'CO2_column' for the reservoir, defined by a gas-water contact depth and pressure. The simulation is initially set to run for zero days (START_DATE = FINAL_DATE) to perform only an initialization run, which generates the EGRID file necessary for building the LGR.</p> <p>After the EGRID file is produced, the LGRBuilder functionality is used to set up the LGR, update transport properties, zonation, and equilibration zones. The user must define the upper limit of the 'CO2_column' equilibration zone, which may extend into the wellbore to represent a continuous column of CO2 connecting the wellbore to the reservoir. This upper boundary is typically defined by the base of the first cement plug above the reservoir, but the user must specify this.</p> <p> Figure 2: Input wellbore visualization from the <code>Well</code> instance (left) and the resulting grid representation colored by permeability in the simulation model (right), with a scale similar to Figure 1.</p> <p>Once the LGR is set up, the END_DATE can be updated to the desired simulation end date. Users can opt for an initialization run to verify the well representation in the simulation grid or proceed with a full simulation run. The duration of the simulation results will depend on the complexity of the problem, the number of nodes, and other setup parameters.</p> <p>Upon completion of the simulation, the output can be explored using standard CIRRUS post-processing tools and techniques. Users have the flexibility to load the simulation results into visualization software such as ResInsight, which provides advanced capabilities for analyzing and interpreting reservoir simulation data. Additionally, users can leverage the modules available in this repository to optimize visualization and gain deeper insights into the simulation outcomes.</p>"},{"location":"gap/#limitations","title":"Limitations","text":"<p>The SCREEN workflow with CIRRUS provides a valuable approach for simulating wellbore dynamics within the context of CCS projects. However, users should be aware of the following limitations:</p> <ul> <li> <p>Porous Media Flow: CIRRUS is primarily designed for porous media flow simulations. While the SCREEN workflow adapts it for wellbore dynamics, it does not include the detailed physics for pipe or open wellbore modeling.</p> </li> <li> <p>Geomechanics: The current workflow does not include coupled geomechanics. Overburden flow is driven by assigned transport properties without accounting for mechanical deformation.</p> </li> <li> <p>Degradation and Corrosion: Complex degradation or corrosion processes within the wellbore are not modeled within CIRRUS.</p> </li> <li> <p>Vertical Wells: The method is currently applicable only to vertical wells and does not support deviated or horizontal well trajectories.</p> </li> <li> <p>Leakage Pathways: Leakage pathways such as holes in the casing are not automatically handled and must be manually added to the GRDECL file produced by the scripts.</p> </li> <li> <p>CO2 Column Initialization: The simulation is initialized with a CO2 column, which allows for the focus on long-term leakage but does not consider short-term dynamics.</p> </li> <li> <p>Boundary Conditions: The workflow does not support time-varying boundary conditions, which may be relevant for certain simulation scenarios.</p> </li> <li> <p>Grid Representation: The use of a Cartesian grid to represent a cylindrical wellbore can introduce volumetric errors due to the transformation into a prism shape.</p> </li> <li> <p>Uncertain Parameters: Cement permeability and transport properties of the overburden are uncertain and can significantly impact simulation results.</p> </li> <li> <p>Grid Resolution: Elements smaller than the LGR resolution may not be accurately represented. While cement bonds are fully represented, their thickness might be smaller than the minimum grid size. Casings are modeled as transmissibility multipliers and act as flow barriers, which may not capture the full complexity of wellbore integrity.</p> </li> </ul> <p>These limitations should be considered when interpreting simulation results and when planning further development of the workflow to ensure that the simulations align with the specific objectives and conditions of the CCS project.</p>"},{"location":"mkdocs/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"mkdocs/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs gh-deploy</code> - Deploy the documentation to GitHub page (<code>gh-pages</code> branch)</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"mkdocs/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.</code></pre>"},{"location":"press_calc/","title":"Press calc","text":"<p>Routine to calculate pressure buildup in well.</p>"},{"location":"well_class/","title":"Pre\u2010processing and Preliminary Assessment","text":"<p>The SCREEN scripts facilitate preliminary analysis by generating two main outputs from the input data:</p> <ul> <li>A wellbore schematic that integrates geological well tops from subsurface data.</li> <li>A pressure depth plot that models the pressure profile along the wellbore.</li> </ul> <p>Users provide input data in CSV or YAML format, which includes the following required parameters:</p> <ul> <li><code>well_header</code>: General well information such as <code>well_name</code>, <code>well_rkb</code>, <code>sf_depth_msl</code>, <code>well_td_rkb</code>, <code>sf_temp</code>, and <code>geo_tgrad</code>.</li> <li><code>drilling</code> table: Interval data for hole sections with top and bottom depths and diameters.</li> <li><code>casing_cement</code> table: Casing and cement records by top and bottom depth, inner diameter, and cement top (TOC) and bottom (BOC) depths. A <code>shoe</code> flag and a <code>permeability</code> value are included.</li> <li><code>barriers</code> table<code>: Depths of cement or mechanical plugs with a</code>permeability` value for modeling.</li> <li><code>geology</code> table`: Geological unit tops, names, and a reservoir indicator. Overburden flow units must be tagged as reservoirs.</li> <li><code>reservoir_pressure</code>: (to be deprecated) Reference for pressure deviations at the reservoir level.</li> <li><code>co2_datum</code>: Depth of the expected base of the gas column, indicating aquifer pressure conditions.</li> </ul> <p>Examples in the <code>test_data</code> folder can be used as templates for structuring the data. The <code>pflotran_gap</code> notebook serves as a reference guide to execute the workflow. The initial step involves using the <code>Well</code> data class to construct the well object:</p> <pre><code>my_well = Well(header       = well_csv['well_header'], \n               drilling     = well_csv['drilling'],\n               casings      = well_csv['casing_cement'],\n               geology      = well_csv['geology'],\n               barriers     = well_csv['barriers'], \n               barrier_perm = well_csv['barrier_permeability'],\n               co2_datum    = well_csv['co2_datum'])\n</code></pre> <p>During this process, all inputs are converted to meters, and depth values are harmonized to be expressed in meters below mean sea level (mMSL). After this conversion, it is possible to generate a visualization of the wellbore schematic.</p> <p>The Well object is then utilized to instantiate the Pressure class and create pressure profiles:</p> <p><pre><code>my_pressure = Pressure(header      = well_csv['well_header'],\n                       reservoir_P = well_csv['reservoir_pressure'],\n                       co2_datum   = well_csv['co2_datum'],\n                       pvt_path    = pvt_path)</code></pre> These profiles are approximations derived from a numerical method that computes pressure. The script begins with known temperature and pressure at a reference depth to calculate initial fluid density. It then applies the equation  <code>\u0394P=\u03c1\u22c5g\u22c5dz</code>, iteratively updating pressure and density over small depth increments. At each step, the new pressure is determined using the updated density and the known temperature gradient, continuing this process throughout the well's depth profile. The integration of differential equations for pressure and density calculations was initially performed using a conventional for loop, but has since been optimized by adopting the <code>solve_ivp</code> method from <code>scipy.integrate</code>, enhancing both efficiency and accuracy.</p> <p>Once the <code>Well</code> and <code>Pressure</code> instances have been created, they can be visualized using the <code>plot_sketch</code> and <code>plot_pressure</code> functions. The <code>plot_sketch</code> function provides a schematic of the wellbore, while the <code>plot_pressure</code> function produces a pressure versus depth plot.</p> <p> Figure 1: Combined visualization of wellbore schematic and pressure depth plot.</p> <p>Additionally, the <code>plot_pt</code> function allows for the visualization of profiles in a Pressure-Temperature plot, which includes phase boundaries and background coloring to indicate fluid density changes.</p> <p> Figure 2: Pressure profile from <code>Pressure</code> instance displayed in a Pressure-Temperature Plot with phase boundaries and fluid density as background color.</p>"},{"location":"well_class/#permeability-handling","title":"Permeability Handling","text":"<p>Although not used in these visualizations, the data structure used to initialize the Well class contains a handle to store permeability values for both the cement bond (<code>casing_cement</code>) and cement plugs (<code>barriers</code>). These values are estimates provided by the user and are subject to significant uncertainty due to factors such as cement quality, curing defects, or fractures, and can vary across orders of magnitude. Users are responsible for providing realistic permeability estimates, drawing on professional judgment and available literature in the absence of concrete data.</p> <p>Flow rates through cement barriers are computed via Darcy\u2019s law using an effective permeability value, which describes the permeability of the entire barrier medium. This effective permeability is higher than the intrinsic permeability of the cement, as it incorporates possible flow paths through cracks and mud channels within the cement. The Hagen-Poiseuille law can be applied to calculate the flow behavior of such composite materials (i.e., cemented pipe/annulus with microannulus) using an equivalent Darcy permeability for laminar flow. The effective permeability of the cemented section, including the microannulus, is obtained by taking the area-weighted averages of the permeabilities of the various components. However, predicting the appropriate microannulus assumptions based on legacy well files can be challenging. The effective permeability of \u201creal-life\u201d cement can vary widely, from microDarcy values for well-cured cement to several darcies for degraded cement. Fortunately, several studies provide estimates of effective well permeabilities based on direct measurements, back-calculation of observed leaking rates, or theoretical studies and modeling tools [1].</p> <p> Figure 3: Range of effective permeability in cement materials. Laboratory-Measured: A[2], B[3], C[4], D[5]. Field-Estimated: E[6], F[7], G[8], H[9]. Used for Modeling: I[10].</p>"},{"location":"well_class/#limitations","title":"Limitations","text":"<ul> <li>The wellbore schematic does not have functionalities to represent internal tubing, casing perforations or multiple discrete cemented sections.</li> <li>Identified overburden flow units should be labeled as reservoirs in the input data.</li> <li>The magnitude of cement permeability is an unconstrained and uncertain parameter.</li> <li>The estimation of fluid pressure using the <code>Pressure</code> class is not a full-fledged simulation but a numerical approach that approximates shut-in pressures or a system in equilibrium. It should not be confused with dynamic simulation models that account for transient conditions and fluid flow in the reservoir and wellbore.</li> </ul>"},{"location":"well_class/#references","title":"References","text":"<ol> <li> <p>Tors\u00e6ter, M., Bello-Palacios, A., Borgerud, L. K., Nyg\u00e5rd, O.-K., Frost, T. K., Hofstad, K. H., &amp; Andrews, J. S. (2024). Evaluating Legacy Well Leakage Risk in CO2 Storage. SSRN Electronic Journal. https://doi.org/10.2139/ssrn.5062896</p> </li> <li> <p>Beltr\u00e1n-Jim\u00e9nez, K., Gardner, D., Kragset, S., Gebremariam, K. F., Reales, O. A. M., Minde, M. W., de Souza, M. I. L., Aasen, J. A., Skadsem, H. J., &amp; Delabroy, L. (2022). Cement properties characterization from a section retrieved from an oil production well after 33 years of downhole exposure. Journal of Petroleum Science and Engineering, 208, 109334. https://doi.org/10.1016/j.petrol.2021.109334</p> </li> <li> <p>Gasda, S. E., Celia, M. A., Wang, J. Z., &amp; Duguid, A. (2013). Wellbore Permeability Estimates from Vertical Interference Testing of Existing Wells. Energy Procedia, 37, 5673-5680. https://doi.org/10.1016/j.egypro.2013.06.489</p> </li> <li> <p>Crow, W., Carey, J. W., Gasda, S., Brian Williams, D., &amp; Celia, M. (2010). Wellbore integrity analysis of a natural CO2 producer. International Journal of Greenhouse Gas Control, 4(2), 186-197. https://doi.org/10.1016/j.ijggc.2009.10.010</p> </li> <li> <p>Carey, J. W., Wigand, M., Chipera, S. J., WoldeGabriel, G., Pawar, R., Lichtner, P. C., Wehner, S. C., Raines, M. A., &amp; Guthrie, G. D. (2007). Analysis and performance of oil well cement with 30 years of CO2 exposure from the SACROC Unit, West Texas, USA. International Journal of Greenhouse Gas Control, 1(1), 75-85. https://doi.org/10.1016/S1750-5836(06)00004-1</p> </li> <li> <p>Kang, M., Baik, E., Miller, A. R., Bandilla, K. W., &amp; Celia, M. A. (2015). Effective Permeabilities of Abandoned Oil and Gas Wells: Analysis of Data from Pennsylvania. Environmental Science &amp; Technology, 49(7), 4757-4764. https://doi.org/10.1021/acs.est.5b00132</p> </li> <li> <p>Carey, J. W. (2018). Probability distributions for effective permeability of potentially leaking wells at CO2 sequestration sites. Los Alamos National Lab.(LANL), Los Alamos, NM (United States). https://doi.org/10.18141/1433164</p> </li> <li> <p>Godoy, R., Fontan, M., Capra, B., Kvalsund, R., &amp; Poupard, O. (2015). Well Integrity Support by Extended Cement Evaluation - Numerical Modeling of Primary Cement Jobs. Abu Dhabi International Petroleum Exhibition and Conference. https://doi.org/10.2118/177612-MS</p> </li> </ol>"},{"location":"well_viz/","title":"WellViz","text":"<p>2D visualization of Pflotran simulation</p>"},{"location":"code_references/gap/gap_carfin/","title":"CARFIN","text":""},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.build_grdecl","title":"<code>src.GaP.libs.carfin.build_grdecl</code>","text":"<p>Module to output the .grdecl file for LGR grid</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.build_grdecl.build_grdecl","title":"<code>build_grdecl(output_folder: str, LGR_NAME: str, casing_list: List[PipeCementModel], barrier_list: List[ElemModel], LGR_sizes_xy: List[float], LGR_depths: np.ndarray, LGR_numb_z: np.ndarray, min_grd_size: float, NX: int, NY: int, main_grd_i: int, main_grd_j: int, main_grd_min_k: int, main_grd_max_k: int, no_of_layers_in_OB: int) -&gt; None</code>","text":"<p>Generate grdecl grid</p> <p>To be able to model a legacy well in reservoir scale, we need to make sure all of the elements including        multiple casings with different OD, cement bonds, barriers, the open area between barriers inside the casings, etc.        are considered. </p> <p>Then, the existing simple well models available in the commercial simulators (Eclipse, PFT, IX) are not  able to\\  include those details. They just introduce a node where the flow will be discharged from/to the grid to the node. </p> <p>The way around it is to define the well as a part of the reservoir by manipulating the local grids (LGR) and properties of the grid, </p> <p>Parameters:</p> <ul> <li> <code>output_folder</code>               (<code>str</code>)           \u2013            <p>output directory</p> </li> <li> <code>LGR_NAME</code>               (<code>str</code>)           \u2013            <p>output filename, without the suffix '.grdecl'</p> </li> <li> <code>casing_list</code>               (<code>list[PipeCementModel]</code>)           \u2013            <p>contains list of casing geometry</p> </li> <li> <code>barrier_list</code>               (<code>list[ElemModel]</code>)           \u2013            <p>contains list of barriers</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> <li> <code>LGR_numb_z</code>               (<code>ndarray</code>)           \u2013            <p>number of chops for each main DZ</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> <li> <code>NX</code>               (<code>int</code>)           \u2013            <p>number of grids in x direction (coarse grid)</p> </li> <li> <code>NY</code>               (<code>int</code>)           \u2013            <p>number of grids in y direction (coarse grid)</p> </li> <li> <code>main_grd_i</code>               (<code>int</code>)           \u2013            <p>x index of well location in coarse grid</p> </li> <li> <code>main_grd_j</code>               (<code>int</code>)           \u2013            <p>y index of well location in coarse grid</p> </li> <li> <code>main_grd_min_k</code>               (<code>int</code>)           \u2013            <p>minimum z index in coarse grid</p> </li> <li> <code>main_grd_max_k</code>               (<code>int</code>)           \u2013            <p>maximum z index in coarse grid</p> </li> <li> <code>no_of_layers_in_OB</code>               (<code>int</code>)           \u2013            <p>number of layers in overburden (coarse grid)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/GaP/libs/carfin/build_grdecl.py</code> <pre><code>def build_grdecl(output_folder: str, \n                 LGR_NAME: str,\n                 casing_list: List[PipeCementModel],\n                 barrier_list: List[ElemModel], \n                 LGR_sizes_xy: List[float], \n                 LGR_depths: np.ndarray,\n                 LGR_numb_z: np.ndarray,\n                 min_grd_size: float,\n                 NX: int, NY: int,\n                 main_grd_i: int, main_grd_j: int,\n                 main_grd_min_k: int, main_grd_max_k: int,\n                 no_of_layers_in_OB: int) -&gt; None:\n    \"\"\" Generate grdecl grid\n\n        To be able to model a legacy well in reservoir scale, we need to make sure all of the elements including\\\n        multiple casings with different OD, cement bonds, barriers, the open area between barriers inside the casings, etc.\\\n        are considered. \n\n        Then, the existing simple well models available in the commercial simulators (Eclipse, PFT, IX) are not  able to\\ \n        include those details. They just introduce a node where the flow will be discharged from/to the grid to the node. \n\n        The way around it is to define the well as a part of the reservoir by manipulating the local grids (LGR) and properties of the grid, \n\n        Args:\n            output_folder (str): output directory\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            casing_list (list[PipeCementModel]): contains list of casing geometry\n            barrier_list (list[ElemModel]): contains list of barriers\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            LGR_numb_z (np.ndarray): number of chops for each main DZ\n            min_grd_size (float): minimum grid size\n            NX (int): number of grids in x direction (coarse grid)\n            NY (int): number of grids in y direction (coarse grid)\n            main_grd_i (int): x index of well location in coarse grid\n            main_grd_j (int): y index of well location in coarse grid\n            main_grd_min_k (int): minimum z index in coarse grid\n            main_grd_max_k (int): maximum z index in coarse grid\n            no_of_layers_in_OB (int): number of layers in overburden (coarse grid)\n\n        Returns:\n            None             \n    \"\"\"\n\n    # 0. prepare file for output\n\n    # check output directory\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder, exist_ok=True)\n\n    # generate output file name\n    out_fname = os.path.join(output_folder, LGR_NAME+'.grdecl')\n\n    # open it\n    if os.path.exists(out_fname):\n        O = open(out_fname,\"r+\")  # noqa: E741\n    else: \n        O = open(out_fname,\"x\")  # noqa: E741\n\n    O.truncate(0)\n\n    # 1. start the process\n    pre_CARFIN(LGR_NAME,\n                NX, NY,\n                main_grd_i, main_grd_j, \n                no_of_layers_in_OB, \n                O)\n\n    CARFIN_keywords(LGR_NAME,\n                    main_grd_i, main_grd_j, \n                    main_grd_min_k, main_grd_max_k, \n                    LGR_sizes_xy, \n                    LGR_numb_z, \n                    min_grd_size,\n                    O)\n\n    coreCARFIN(LGR_NAME,\n                casing_list,\n                barrier_list,\n                LGR_sizes_xy, \n                LGR_depths, \n                min_grd_size,\n                O)\n\n    # find minimum IDs\n    reopen_ID = sys.float_info.max\n    for casing in casing_list:\n        if casing.ID &lt; reopen_ID:\n            reopen_ID = casing.ID\n\n    endCARFIN(LGR_NAME,\n                reopen_ID,\n                LGR_sizes_xy, \n                main_grd_min_k, \n                min_grd_size,\n                no_of_layers_in_OB,\n                O)\n\n    # 2. done\n    O.close()\n\n    # for qc\n    print ('Output LGR CARFIN to: ', os.path.abspath(out_fname))</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_barrier","title":"<code>src.GaP.libs.carfin.CARFIN_barrier</code>","text":"<p>barrier builder</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_barrier.CARFIN_barrier","title":"<code>CARFIN_barrier(ID: float, x_min_bar: int, x_max_bar: int, y_min_bar: int, y_max_bar: int, k_min_bar: int, k_max_bar: int, perm: float, LGR_NAME: str, O: TextIO)</code>","text":"<p>CARFIN for barrier</p> <p>The barriers can be mimicked by very low permeability with the same size of pipe ID and have their own start and end depth. </p> <p>Parameters:</p> <ul> <li> <code>ID</code>               (<code>float</code>)           \u2013            <p>Internal Diameter (m)</p> </li> <li> <code>x_min_bar</code>               (<code>int</code>)           \u2013            <p>minimum x</p> </li> <li> <code>x_max_bar</code>               (<code>int</code>)           \u2013            <p>maximum x</p> </li> <li> <code>y_min_bar</code>               (<code>int</code>)           \u2013            <p>minimum y</p> </li> <li> <code>y_max_bar</code>               (<code>int</code>)           \u2013            <p>maximum y</p> </li> <li> <code>k_min_bar</code>               (<code>int</code>)           \u2013            <p>minimum k</p> </li> <li> <code>k_max_bar</code>               (<code>int</code>)           \u2013            <p>maximum k</p> </li> <li> <code>perm</code>               (<code>float</code>)           \u2013            <p>permeability value</p> </li> <li> <code>LGR_NAME</code>               (<code>str</code>)           \u2013            <p>LGR name</p> </li> <li> <code>O</code>               (<code>TextIO</code>)           \u2013            <p>opened file handle</p> </li> </ul> Source code in <code>src/GaP/libs/carfin/CARFIN_barrier.py</code> <pre><code>def CARFIN_barrier(ID: float, \n                     x_min_bar: int, x_max_bar: int,\n                     y_min_bar: int, y_max_bar: int,\n                     k_min_bar: int, k_max_bar: int,\n                     perm: float,\n                     LGR_NAME: str, \n                     O: TextIO):  # noqa: E741\n    \"\"\" CARFIN for barrier\n\n        The barriers can be mimicked by very low permeability with the same size of pipe ID and have their own start and end depth. \n\n        Args:\n            ID (float): Internal Diameter (m)\n            x_min_bar (int): minimum x\n            x_max_bar (int): maximum x\n            y_min_bar (int): minimum y\n            y_max_bar (int): maximum y\n            k_min_bar (int): minimum k\n            k_max_bar (int): maximum k\n            perm (float): permeability value\n            LGR_NAME (str): LGR name\n            O (TextIO): opened file handle\n    \"\"\"\n\n    print ('EQUALS',file=O)\n\n    print ('--barrier with ID of',ID*39.37,'and perm of',perm,' were set in',LGR_NAME, file=O)\n    print ('PERMX','',perm,'',x_min_bar,'',x_max_bar,'',y_min_bar,'',y_max_bar,'',k_min_bar,'',k_max_bar,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_bar,'',x_max_bar,'',y_min_bar,'',y_max_bar,'',k_min_bar,'',k_max_bar,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_bar,'',x_max_bar,'',y_min_bar,'',y_max_bar,'',k_min_bar,'',k_max_bar,'','/',file=O)\n    print ('PORO','','0.01','',x_min_bar,'',x_max_bar,'',y_min_bar,'',y_max_bar,'',k_min_bar,'',k_max_bar,'','/',file=O)\n\n    print ('/',file=O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_cement_bond","title":"<code>src.GaP.libs.carfin.CARFIN_cement_bond</code>","text":"<p>cement bond builder</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_cement_bond.CARFIN_cement_bond","title":"<code>CARFIN_cement_bond(ID: float, x_min_pipe: int, x_max_pipe: int, y_min_pipe: int, y_max_pipe: int, k_min_CB: int, k_max_CB: int, *, x_bd=1, y_bd=1, perm: float, LGR_NAME: str, O: TextIO)</code>","text":"<p>CARFIN for cement bond</p> <p>The cement bond can be mimicked by low perm vertical layer adjustment to the casing with given depth and interval. </p> <p>Parameters:</p> <ul> <li> <code>ID</code>               (<code>float</code>)           \u2013            <p>Internal Diameter (m), only for comments, not used in calculation</p> </li> <li> <code>x_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum x for actual internal open hole</p> </li> <li> <code>x_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum x for actual internal open hole</p> </li> <li> <code>y_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum y for actual internal open hole</p> </li> <li> <code>y_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum y for actual internal open hole</p> </li> <li> <code>k_min_CB</code>               (<code>int</code>)           \u2013            <p>minimum k for actual internal open hole</p> </li> <li> <code>k_max_CB</code>               (<code>int</code>)           \u2013            <p>maximum k for actual internal open hole</p> </li> <li> <code>x_bd</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>x thickness for out extension, default: 1</p> </li> <li> <code>y_bd</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>y thickness  for out extension, default: 1</p> </li> <li> <code>perm</code>               (<code>float</code>)           \u2013            <p>permeability value</p> </li> <li> <code>LGR_NAME</code>               (<code>str</code>)           \u2013            <p>LGR name</p> </li> <li> <code>O</code>               (<code>TextIO</code>)           \u2013            <p>opened file handle</p> </li> </ul> Source code in <code>src/GaP/libs/carfin/CARFIN_cement_bond.py</code> <pre><code>def CARFIN_cement_bond(ID: float, \n                        x_min_pipe: int, x_max_pipe: int,\n                        y_min_pipe: int, y_max_pipe: int,\n                        k_min_CB: int, k_max_CB: int,\n                        *,\n                        x_bd=1, y_bd=1,\n                        perm: float,\n                        LGR_NAME: str, \n                        O: TextIO):  # noqa: E741\n    \"\"\" CARFIN for cement bond\n\n        The cement bond can be mimicked by low perm vertical layer adjustment to the casing with given depth and interval. \n\n        Args:\n            ID (float): Internal Diameter (m), only for comments, not used in calculation\n            x_min_pipe (int): minimum x for actual internal open hole\n            x_max_pipe (int): maximum x for actual internal open hole\n            y_min_pipe (int): minimum y for actual internal open hole\n            y_max_pipe (int): maximum y for actual internal open hole\n            k_min_CB (int): minimum k for actual internal open hole\n            k_max_CB (int): maximum k for actual internal open hole\n            x_bd (int): x thickness for out extension, default: 1\n            y_bd (int): y thickness  for out extension, default: 1\n            perm (float): permeability value\n            LGR_NAME (str): LGR name\n            O (TextIO): opened file handle\n    \"\"\"\n\n    print ('EQUALS',file=O)\n\n    print ('--cement around pipe with ID of',ID*39.37,' and perm of',perm,' were set in',LGR_NAME,file=O)\n    print ('--Top side',file=O)\n    print ('PERMX','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PORO','', 0.01,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('FIPLEG','',6,'',  x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('EQLNUM','',1,'',  x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_min_pipe-y_bd,'',y_min_pipe-1,'',k_min_CB,'',k_max_CB,'','/',file=O)\n\n    print ('',file=O)\n\n    print ('--Bottom side',file=O)\n    print ('PERMX','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PORO','', 0.01,'',x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('FIPLEG','',6,''  ,x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('EQLNUM','',1,''  ,x_min_pipe-x_bd,'',x_max_pipe+x_bd,'',y_max_pipe+1,'',y_max_pipe+y_bd,'',k_min_CB,'',k_max_CB,'','/',file=O)\n\n    print ('',file=O)\n\n    print ('--Left side',file=O) \n    print ('PERMX','',perm,'',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PORO','', 0.01,'',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('FIPLEG','',6,  '',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('EQLNUM','',1,  '',x_min_pipe-x_bd,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n\n    print ('--Right side',file=O)\n\n    print ('PERMX','',perm,'',x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMY','',perm,'',x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PERMZ','',perm,'',x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('PORO','', 0.01,'',x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('FIPLEG','',6,''  ,x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n    print ('EQLNUM','',1,''  ,x_max_pipe+1,'',x_max_pipe+x_bd,'',y_min_pipe,'',y_max_pipe,'',k_min_CB,'',k_max_CB,'','/',file=O)\n\n    print ('/',file=O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core","title":"<code>src.GaP.libs.carfin.CARFIN_core</code>","text":"<p>generate grdecl grid</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core.pre_CARFIN","title":"<code>pre_CARFIN(LGR_NAME: str, NX: int, NY: int, main_grd_i: int, main_grd_j: int, no_of_layers_in_OB: int, O: TextIO)</code>","text":"<p>preCARFIN</p> <p>Before introducing the CARFIN, we need to make sure there is a sealing layer between the overburden and the reservoir.</p> <p>We borrow  the topmost layer of the reservoir and make it seal against both vertical (MULTZ=0) and side (MULTX, MULTY= 0)  flow toward the overburden. </p> <p>But, we still need to make sure that the topmost layer is open in where the LGR is located to allow the only flow communication  between the overburden and the reservoir being through the well </p> <p>Later we will close the rest of topmost layer inside the LGR and only open an area of LGR where the main pipe is paths.</p> <p>Depend on the case, we may want to open the cement bonds in that area.   </p> <p>Args:</p> <pre><code>LGR_NAME (str): output filename, without the suffix '.grdecl'\nNX (int): number of grids in x direction (coarse grid)\nNY (int): number of grids in y direction (coarse grid)\nmain_grd_i (int): x index of well location in coarse grid\nmain_grd_j (int): y index of well location in coarse grid\nno_of_layers_in_OB (int): number of layers in overburden (coarse grid)\nO (TextIO): opened file handle</code></pre> Source code in <code>src/GaP/libs/carfin/CARFIN_core.py</code> <pre><code>def pre_CARFIN(LGR_NAME: str,\n               NX: int, NY: int,\n               main_grd_i: int, main_grd_j: int, \n               no_of_layers_in_OB: int, \n               O: TextIO):  # noqa: E741\n    \"\"\" preCARFIN\n\n        Before introducing the CARFIN, we need to make sure there is a sealing layer between the overburden and the reservoir.\n\n        We borrow  the topmost layer of the reservoir and make it seal against both vertical (MULTZ=0) and side (MULTX, MULTY= 0) \n        flow toward the overburden. \n\n        But, we still need to make sure that the topmost layer is open in where the LGR is located to allow the only flow communication \n        between the overburden and the reservoir being through the well \n\n        Later we will close the rest of topmost layer inside the LGR and only open an area of LGR where the main pipe is paths.\n\n        Depend on the case, we may want to open the cement bonds in that area.   \n\n        Args:\n\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            NX (int): number of grids in x direction (coarse grid)\n            NY (int): number of grids in y direction (coarse grid)\n            main_grd_i (int): x index of well location in coarse grid\n            main_grd_j (int): y index of well location in coarse grid\n            no_of_layers_in_OB (int): number of layers in overburden (coarse grid)\n            O (TextIO): opened file handle            \n    \"\"\"\n\n    # PRE-CARFIN, isolates OVB from reservoir \n    print ('...Prints isolating OVB from reservoir keywords in', LGR_NAME+'.grdecl file')\n\n    print ('--isolating OVB from reservoir', file=O)\n    print ('EQUALS', file = O) \n    # print ('MULTX  0 ','1 ',NX, '1 ',NY,no_of_layers_in_OB+1,no_of_layers_in_OB+1,'/',file = O)\n    # print ('MULTY  0 ','1 ',NX, '1 ',NY,no_of_layers_in_OB+1,no_of_layers_in_OB+1,'/',file = O)\n    # print ('MULTZ  0 ','1 ',NX, '1 ',NY,no_of_layers_in_OB+1,no_of_layers_in_OB+1,'/',file = O)\n    # print ('MULTX  1 ',main_grd_i, main_grd_i,main_grd_j, main_grd_j, no_of_layers_in_OB+1, no_of_layers_in_OB+1, '/',file =O)\n    # print ('MULTY  1 ',main_grd_i, main_grd_i,main_grd_j, main_grd_j, no_of_layers_in_OB+1, no_of_layers_in_OB+1, '/',file =O)\n    # print ('MULTZ  1 ',main_grd_i, main_grd_i,main_grd_j, main_grd_j, no_of_layers_in_OB+1, no_of_layers_in_OB+1, '/',file =O)\n\n    # TODO(hzh): This should be right\n    print ('MULTZ  0 ','1 ',NX, '1 ',NY,no_of_layers_in_OB,no_of_layers_in_OB,'/',file = O)\n    print ('MULTZ  1 ',main_grd_i, main_grd_i,main_grd_j, main_grd_j, no_of_layers_in_OB, no_of_layers_in_OB, '/',file =O)\n\n    print ('/', file = O) \n    print (' ', file = O) </code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core.CARFIN_keywords","title":"<code>CARFIN_keywords(LGR_NAME: str, main_grd_i: int, main_grd_j: int, main_grd_min_k: int, main_grd_max_k: int, LGR_sizes_xy: List[float], LGR_numb_z: np.ndarray, min_grd_size: float, O: TextIO)</code>","text":"<p>CARFIN main parameters</p> <p>CARFIN is the main keyword which introduces LGR into the  grid. </p> <p>The keyword has the following parameters which had be filled in: </p> <pre><code>LGR Name: the name of LGR that we want to create. \n          This name is the same as the name that the script uses to generate the output file, i.e. LGRNAME.grdecl\n\nThere are 6 parameter which define where the LGR should be located in the main grid which are:\n\n    main grid i-start, main grid i-end, main grid j-start, main grid j-end, main grid k-start, main grid k-end.\n\nIn our case, we always have a vertical well, therefore main grid i-start = main grid i-end are the same for j direction.\n\nNXFIN and NYFIN: they dictate how many times per grid (in the same order) should  be chopped. In our case, \n                 there is only one grid assigned in the X and Y directions. Therefore, the numbers will be the same as \n                 8th and 9th parameters in CARFIN.\n\nNZFIN: unlike X,Y direcitons, there are multiple grids involved in the Z direction of the main grid. \n        The main grids in the overburden in the Z direction are hard-coded to be chopped to 10 grids.\n        The main grids in the Z direction in the reservoir should remain un-refined. Therefore, the assigned number of chops should be equal to 1. \n        This is all already stored in the LGR_numb_z.\n\nHXFIN and HYFIN: They are going to provide multiple sizes in X and Y direction. This is mainly high resolution down to min_grd_size \n                 in the center of the grid and increasing the size of the grids toward the outermost side of the grid.\n\n                The HXFIN and HYFIN are working not with real sizes but with \u201cratio\u201d. \n                The lowest grid size has the ratio equal to min_grd_size/min_grd_size = 1.\n\n                Then the rest of grid sizes are calculated as follows:\n                    Grid size of the refined grid /min_grd_size. \n                    The min_grid_size presented in slide7   \n                    Grid sizes in x,y direction are presented in the slide 8</code></pre> <p>Args:</p> <pre><code>LGR_NAME (str): output filename, without the suffix '.grdecl'\nmain_grd_i (int): x index of well location in coarse grid\nmain_grd_j (int): y index of well location in coarse grid\nmain_grd_min_k (int): minimum z index in coarse grid\nmain_grd_max_k (int): maximum z index in coarse grid\nLGR_sizes_xy (list[float]): LGR xy grid intervals\nLGR_numb_z (np.ndarray): number of chops for each main DZ\nmin_grd_size (float): minimum grid size\nO (TextIO): opened file handle</code></pre> Source code in <code>src/GaP/libs/carfin/CARFIN_core.py</code> <pre><code>def CARFIN_keywords(LGR_NAME: str,\n                    main_grd_i: int, main_grd_j: int, \n                    main_grd_min_k: int, main_grd_max_k: int, \n                    LGR_sizes_xy: List[float], \n                    LGR_numb_z: np.ndarray, \n                    min_grd_size: float,\n                    O: TextIO):  # noqa: E741\n    \"\"\" CARFIN main parameters\n\n        CARFIN is the main keyword which introduces LGR into the  grid. \n\n        The keyword has the following parameters which had be filled in: \n\n            LGR Name: the name of LGR that we want to create. \n                      This name is the same as the name that the script uses to generate the output file, i.e. LGRNAME.grdecl \n\n            There are 6 parameter which define where the LGR should be located in the main grid which are:\n\n                main grid i-start, main grid i-end, main grid j-start, main grid j-end, main grid k-start, main grid k-end. \n\n            In our case, we always have a vertical well, therefore main grid i-start = main grid i-end are the same for j direction.  \n\n            NXFIN and NYFIN: they dictate how many times per grid (in the same order) should  be chopped. In our case, \n                             there is only one grid assigned in the X and Y directions. Therefore, the numbers will be the same as \n                             8th and 9th parameters in CARFIN. \n\n            NZFIN: unlike X,Y direcitons, there are multiple grids involved in the Z direction of the main grid. \n                    The main grids in the overburden in the Z direction are hard-coded to be chopped to 10 grids.\n                    The main grids in the Z direction in the reservoir should remain un-refined. Therefore, the assigned number of chops should be equal to 1. \n                    This is all already stored in the LGR_numb_z.\n\n            HXFIN and HYFIN: They are going to provide multiple sizes in X and Y direction. This is mainly high resolution down to min_grd_size \n                             in the center of the grid and increasing the size of the grids toward the outermost side of the grid. \n\n                            The HXFIN and HYFIN are working not with real sizes but with \u201cratio\u201d. \n                            The lowest grid size has the ratio equal to min_grd_size/min_grd_size = 1. \n\n                            Then the rest of grid sizes are calculated as follows:\n                                Grid size of the refined grid /min_grd_size. \n                                The min_grid_size presented in slide7   \n                                Grid sizes in x,y direction are presented in the slide 8\n\n        Args:\n\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            main_grd_i (int): x index of well location in coarse grid\n            main_grd_j (int): y index of well location in coarse grid\n            main_grd_min_k (int): minimum z index in coarse grid\n            main_grd_max_k (int): maximum z index in coarse grid\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_numb_z (np.ndarray): number of chops for each main DZ\n            min_grd_size (float): minimum grid size\n            O (TextIO): opened file handle            \n    \"\"\"\n\n    # prints CARFIN KEYWORD in Eclipse \n    print ('...Prints CARFIN Keywords in', LGR_NAME+'.grdecl file')\n\n    print ('CARFIN',file=O)\n    print (LGR_NAME ,main_grd_i, main_grd_i, main_grd_j, main_grd_j, main_grd_min_k, main_grd_max_k, len(LGR_sizes_xy), len(LGR_sizes_xy), sum(LGR_numb_z) , '/',file=O)\n\n    print (' ',file=O)\n    print ('NXFIN',file=O)\n    print (len(LGR_sizes_xy),'/',file=O)\n\n    print (' ',file=O)\n    print ('NYFIN',file=O)\n    print (len(LGR_sizes_xy),'/',file=O)\n\n    print (' ',file=O)\n    print ('NZFIN',file=O)\n    print (*LGR_numb_z, '/',file=O)\n    print (' ',file=O)\n    print ('HXFIN',file=O) \n    print  (*[round (x/ min_grd_size,2) for x in LGR_sizes_xy],'/',file=O) \n    print (' ',file=O) \n    print ('HYFIN',file=O)\n    print  (*[round (x/ min_grd_size,2) for x in LGR_sizes_xy],'/',file=O) \n    print (' ',file=O)\n    print (' ',file=O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core.coreCARFIN","title":"<code>coreCARFIN(LGR_NAME: str, casing_list: List[Union[PipeCementModel, ElemModel]], barrier_list: List[ElemModel], LGR_sizes_xy: List[float], LGR_depths: np.ndarray, min_grd_size: float, O: TextIO)</code>","text":"<p>CARFIN for the main elements</p> <p>Args:</p> <pre><code>LGR_NAME (str): output filename, without the suffix '.grdecl'\ncasing_list (list[PipeCementModel]): contains list of casing geometry\nbarrier_list (list[ElemModel]): contains list of barriers\nLGR_sizes_xy (list[float]): LGR xy grid intervals\nLGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\nmin_grd_size (float): minimum grid size\nO (TextIO): opened file handle</code></pre> Source code in <code>src/GaP/libs/carfin/CARFIN_core.py</code> <pre><code>def coreCARFIN(LGR_NAME: str,\n                casing_list: List[Union[PipeCementModel, ElemModel]],\n                barrier_list: List[ElemModel],\n                LGR_sizes_xy: List[float], \n                LGR_depths: np.ndarray, \n                min_grd_size: float,\n                O: TextIO):  # noqa: E741\n    \"\"\" CARFIN for the main elements\n\n        Args:\n\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            casing_list (list[PipeCementModel]): contains list of casing geometry\n            barrier_list (list[ElemModel]): contains list of barriers\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            min_grd_size (float): minimum grid size\n            O (TextIO): opened file handle            \n\n    \"\"\"\n\n    print ('...Prints Casings, cement bonds and barrie(s) in', LGR_NAME+'.grdecl file')\n\n    # loop around Conductor casing, Surface casing, and Production casing\n    for idx, casing in enumerate(casing_list):\n        if type(casing) is PipeCementModel:\n            CARFIN_pipe_and_cement_bond_builder(casing, \n                                                LGR_sizes_xy, LGR_depths, \n                                                min_grd_size,\n                                                LGR_NAME, \n                                                O)\n        elif type(casing) is ElemModel:\n            CARFIN_oph_builder(casing, \n                                LGR_sizes_xy, LGR_depths, \n                                min_grd_size,\n                                LGR_NAME, \n                                O)\n        else:\n            continue\n\n    # 4. optional: to add barrier inside the well\n    if len(barrier_list):\n\n        for _, barrier in enumerate(barrier_list):\n\n            CARFIN_barrier_builder(barrier, \n                                    LGR_sizes_xy, LGR_depths, \n                                    min_grd_size,\n                                    LGR_NAME, \n                                    O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core.endCARFIN","title":"<code>endCARFIN(LGR_NAME: str, reopen_ID: float, LGR_sizes_xy: List[float], main_grd_min_k: float, min_grd_size: float, no_of_layers_in_OB: int, O: TextIO)</code>","text":"<p>ENDFIN</p> <p>Before we finish the CARFIN with ENDFIN, we will have to close the area around the well inside the LGR:</p> <pre><code>As mentioned in the slide 22, we opened the whole LGR in the topmost layer of the reservoir (and closed the rest of topmost layer.\n\nIn this stage we will have to make sure there is no flow around the well inside the LGR from the reservoir to the overburden.\n\nTo do that we will first close the whole topmost layer inside the LGR:\n\n    The whole LGR grids in the x,y directions should be closed in the topmost layer but inside LGR.\n\n    Then we will  set the MULTX, MULTY and MULTZ multipliers to 0 to make sure the area is whole closed.\n\nThen we re-open the area where the well paths. In order to do that, we will have to (again) find that which pipe (with which ID) \nis pathing through the caprock (from overburden to the caprock):\n\n    The code always assumes the narrowest pipe passing through the caprock.\n\n    We find X_min, X_max, Y_min, Y_max of the narrowest pipe.\n\nKnowing, how many layer are allocated to overburden and given 10 chops per grid in the Z direction, we can find the k_min and k_max of \nthe pipe where we want to leave it open.\n\nThen, we let the MULTZ (only) equal to one in that domain. We don't want to allow side movement of CO2 in the caprock.</code></pre> <p>Args:</p> <pre><code>LGR_NAME (str): output filename, without the suffix '.grdecl'\nreopen_ID (str): minimum ID of all casings\nLGR_sizes_xy (list[float]): LGR xy grid intervals\nmain_grd_min_k (int): minimum z index in coarse grid\nno_of_layers_in_OB (int): number of layers in overburden (coarse grid)\nO (TextIO): opened file handle</code></pre> Source code in <code>src/GaP/libs/carfin/CARFIN_core.py</code> <pre><code>def endCARFIN(LGR_NAME: str,\n             reopen_ID: float,\n             LGR_sizes_xy: List[float], \n             main_grd_min_k: float, \n             min_grd_size: float,\n             no_of_layers_in_OB: int,\n             O: TextIO):  # noqa: E741\n    \"\"\" ENDFIN\n\n        Before we finish the CARFIN with ENDFIN, we will have to close the area around the well inside the LGR:\n\n            As mentioned in the slide 22, we opened the whole LGR in the topmost layer of the reservoir (and closed the rest of topmost layer.\n\n            In this stage we will have to make sure there is no flow around the well inside the LGR from the reservoir to the overburden. \n\n            To do that we will first close the whole topmost layer inside the LGR:\n\n                The whole LGR grids in the x,y directions should be closed in the topmost layer but inside LGR. \n\n                Then we will  set the MULTX, MULTY and MULTZ multipliers to 0 to make sure the area is whole closed.\n\n            Then we re-open the area where the well paths. In order to do that, we will have to (again) find that which pipe (with which ID) \n            is pathing through the caprock (from overburden to the caprock):\n\n                The code always assumes the narrowest pipe passing through the caprock.  \n\n                We find X_min, X_max, Y_min, Y_max of the narrowest pipe.\n\n            Knowing, how many layer are allocated to overburden and given 10 chops per grid in the Z direction, we can find the k_min and k_max of \n            the pipe where we want to leave it open. \n\n            Then, we let the MULTZ (only) equal to one in that domain. We don't want to allow side movement of CO2 in the caprock. \n\n        Args:\n\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            reopen_ID (str): minimum ID of all casings\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            main_grd_min_k (int): minimum z index in coarse grid\n            no_of_layers_in_OB (int): number of layers in overburden (coarse grid)\n            O (TextIO): opened file handle                 \n    \"\"\"\n\n    # close the whole topmost layer inside the LGR\n    print ('...Prints isolating OVB from reservoir in the LGR in', LGR_NAME+'.grdecl file')\n\n    #Trans. modification to isolate OVB from Reservoir inside the LGR\n    print ('--isolating OVB from reservoir in the LGR',file = O)\n    print ('EQUALS',file = O ) \n    print ('MULTX  0 ','1 ',len(LGR_sizes_xy), '1 ',len(LGR_sizes_xy),(no_of_layers_in_OB-main_grd_min_k+1)*10+1,(no_of_layers_in_OB-main_grd_min_k+1)*10+1,'/',file = O )\n    print ('MULTY  0 ','1 ',len(LGR_sizes_xy), '1 ',len(LGR_sizes_xy),(no_of_layers_in_OB-main_grd_min_k+1)*10+1,(no_of_layers_in_OB-main_grd_min_k+1)*10+1,'/',file = O )\n    print ('MULTZ  0 ','1 ',len(LGR_sizes_xy), '1 ',len(LGR_sizes_xy),(no_of_layers_in_OB-main_grd_min_k+1)*10+1,(no_of_layers_in_OB-main_grd_min_k+1)*10+1,'/',file = O )\n\n    # re-open the area where the well paths\n\n    # x\n    no_grd_reopen_x = math.floor(reopen_ID/min_grd_size)\n    x_min_reopen = math.ceil((len (LGR_sizes_xy) - no_grd_reopen_x)/2)\n    x_max_reopen = x_min_reopen + no_grd_reopen_x\n\n    # y\n    no_grd_reopen_y = math.floor(reopen_ID/min_grd_size)  \n    y_min_reopen = math.ceil((len (LGR_sizes_xy) - no_grd_reopen_y)/2)\n    y_max_reopen = y_min_reopen + no_grd_reopen_y \n\n    print ('MULTZ 1 ', x_min_reopen-1,x_max_reopen+1,y_min_reopen-1 ,y_max_reopen+1 ,(no_of_layers_in_OB-main_grd_min_k+1)*10+1 ,(no_of_layers_in_OB-main_grd_min_k+1)*10+1 ,'/',file = O)\n\n    print ('/', file = O) \n\n    print ('ENDFIN', file = O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_core.endCARFIN2","title":"<code>endCARFIN2(LGR_NAME: str, reopen_ID: float, x_min_reopen: int, x_max_reopen: int, nz_ovb: int, LGR_sizes_xy: List[float], O: TextIO)</code>","text":"<p>ENDFIN</p> <p>Before we finish the CARFIN with ENDFIN, we will have to close the area around the well inside the LGR:</p> <pre><code>As mentioned in the slide 22, we opened the whole LGR in the topmost layer of the reservoir (and closed the rest of topmost layer.\n\nIn this stage we will have to make sure there is no flow around the well inside the LGR from the reservoir to the overburden.\n\nTo do that we will first close the whole topmost layer inside the LGR:\n\n    The whole LGR grids in the x,y directions should be closed in the topmost layer but inside LGR.\n\n    Then we will  set the MULTX, MULTY and MULTZ multipliers to 0 to make sure the area is whole closed.\n\nThen we re-open the area where the well paths. In order to do that, we will have to (again) find that which pipe (with which ID) \nis pathing through the caprock (from overburden to the caprock):\n\n    The code always assumes the narrowest pipe passing through the caprock.\n\n    We find X_min, X_max, Y_min, Y_max of the narrowest pipe.\n\nKnowing, how many layer are allocated to overburden and given 10 chops per grid in the Z direction, we can find the k_min and k_max of \nthe pipe where we want to leave it open.\n\nThen, we let the MULTZ (only) equal to one in that domain. We don't want to allow side movement of CO2 in the caprock.</code></pre> <p>Args:</p> <pre><code>LGR_NAME (str): output filename, without the suffix '.grdecl'\nreopen_ID (str): minimum ID of all casings\nLGR_sizes_xy (list[float]): LGR xy grid intervals\nmain_grd_min_k (int): minimum z index in coarse grid\nno_of_layers_in_OB (int): number of layers in overburden (coarse grid)\nO (TextIO): opened file handle</code></pre> Source code in <code>src/GaP/libs/carfin/CARFIN_core.py</code> <pre><code>def endCARFIN2(LGR_NAME: str,\n                reopen_ID: float, \n                x_min_reopen: int, \n                x_max_reopen: int, \n                nz_ovb: int,\n                LGR_sizes_xy: List[float], \n                O: TextIO):  # noqa: E741\n    \"\"\" ENDFIN\n\n        Before we finish the CARFIN with ENDFIN, we will have to close the area around the well inside the LGR:\n\n            As mentioned in the slide 22, we opened the whole LGR in the topmost layer of the reservoir (and closed the rest of topmost layer.\n\n            In this stage we will have to make sure there is no flow around the well inside the LGR from the reservoir to the overburden. \n\n            To do that we will first close the whole topmost layer inside the LGR:\n\n                The whole LGR grids in the x,y directions should be closed in the topmost layer but inside LGR. \n\n                Then we will  set the MULTX, MULTY and MULTZ multipliers to 0 to make sure the area is whole closed.\n\n            Then we re-open the area where the well paths. In order to do that, we will have to (again) find that which pipe (with which ID) \n            is pathing through the caprock (from overburden to the caprock):\n\n                The code always assumes the narrowest pipe passing through the caprock.  \n\n                We find X_min, X_max, Y_min, Y_max of the narrowest pipe.\n\n            Knowing, how many layer are allocated to overburden and given 10 chops per grid in the Z direction, we can find the k_min and k_max of \n            the pipe where we want to leave it open. \n\n            Then, we let the MULTZ (only) equal to one in that domain. We don't want to allow side movement of CO2 in the caprock. \n\n        Args:\n\n            LGR_NAME (str): output filename, without the suffix '.grdecl'\n            reopen_ID (str): minimum ID of all casings\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            main_grd_min_k (int): minimum z index in coarse grid\n            no_of_layers_in_OB (int): number of layers in overburden (coarse grid)\n            O (TextIO): opened file handle                 \n    \"\"\"\n\n    # close the whole topmost layer inside the LGR\n    print ('...Prints isolating OVB from reservoir in the LGR in', LGR_NAME+'.grdecl file')\n\n    print (f'...reopenID = {reopen_ID*39.37:.2f} ...')\n\n    #Trans. modification to isolate OVB from Reservoir inside the LGR\n    print ('--isolating OVB from reservoir in the LGR',file = O)\n    print ('EQUALS',file = O ) \n\n    # close the last flat ovb surface\n    print ('MULTZ  0 ','1 ',len(LGR_sizes_xy), '1 ',len(LGR_sizes_xy), nz_ovb, nz_ovb,'/',file = O )\n\n\n    # open well borehole at ovb\n    print ('MULTZ 1 ', x_min_reopen, x_max_reopen, x_min_reopen, x_max_reopen, nz_ovb, nz_ovb, '/',file = O)\n\n    print ('/', file = O) \n\n    print ('ENDFIN', file = O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_pipe_with_oph","title":"<code>src.GaP.libs.carfin.CARFIN_pipe_with_oph</code>","text":"<p>pipe builder with open hole sections</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_pipe_with_oph.CARFIN_pipe_with_oph","title":"<code>CARFIN_pipe_with_oph(ID: float, x_min_pipe: int, x_max_pipe: int, y_min_pipe: int, y_max_pipe: int, k_min_pipe: int, k_max_pipe: int, k_min_hole: int, k_max_hole: int, perm: float, LGR_NAME: str, O: TextIO)</code>","text":"<p>CARFIN for pipe with open hole sections</p> <p>The pipes can be mimicked by a very narrow (in the size of ID of a pipe-20 to 50 cm) and high permeability grids.  Those grids could be surrounded by grids with zero transmissibility. </p> <p>The open hole sections can be modelled the same as pipe, but without zero transmissibility around the high perm. area  to allow moving of fluids side ways from the piper. This is particularly important in the cases where there is a  drilled but uncased hole in the setting. </p> <p>First the pipe (high) permeabilities are assigned to the whole pipe ( casing + openhole section) because both casing and  openhole are sharing the highest permeability inner  most layer.</p> <p>The SATNUM = 2 is added to prosperities change. The idea is to have linear rel.perms to the second saturation table, so that  there will be least resistance for flow in the free pipe. </p> <p>Then to mimic the pipe, there should be no flow on the side ways, therefore, the transmisibilities in the X and Y directions  in the edge of the pipe are set to zero. </p> <p>Parameters:</p> <ul> <li> <code>ID</code>               (<code>float</code>)           \u2013            <p>Internal Diameter (m)</p> </li> <li> <code>x_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum x</p> </li> <li> <code>x_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum x</p> </li> <li> <code>y_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum y</p> </li> <li> <code>y_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum y</p> </li> <li> <code>k_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum k of pipe</p> </li> <li> <code>k_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum k of pipe</p> </li> <li> <code>k_min_hole</code>               (<code>int</code>)           \u2013            <p>minimum k of open hole section</p> </li> <li> <code>k_max_hole</code>               (<code>int</code>)           \u2013            <p>maximum k of open hole section</p> </li> <li> <code>perm</code>               (<code>float</code>)           \u2013            <p>permeability value</p> </li> <li> <code>LGR_NAME</code>               (<code>str</code>)           \u2013            <p>LGR name</p> </li> <li> <code>O</code>               (<code>TextIO</code>)           \u2013            <p>opened file handle</p> </li> </ul> Source code in <code>src/GaP/libs/carfin/CARFIN_pipe_with_oph.py</code> <pre><code>def CARFIN_pipe_with_oph(ID: float,\n                            x_min_pipe: int, x_max_pipe: int,\n                            y_min_pipe: int, y_max_pipe: int,\n                            k_min_pipe: int, k_max_pipe: int,\n                            k_min_hole: int, k_max_hole: int,\n                            perm: float,\n                            LGR_NAME: str,\n                            O: TextIO):  # noqa: E741\n    \"\"\" CARFIN for pipe with open hole sections\n\n        The pipes can be mimicked by a very narrow (in the size of ID of a pipe-20 to 50 cm) and high permeability grids. \n        Those grids could be surrounded by grids with zero transmissibility. \n\n        The open hole sections can be modelled the same as pipe, but without zero transmissibility around the high perm. area \n        to allow moving of fluids side ways from the piper. This is particularly important in the cases where there is a \n        drilled but uncased hole in the setting. \n\n        First the pipe (high) permeabilities are assigned to the whole pipe ( casing + openhole section) because both casing and \n        openhole are sharing the highest permeability inner  most layer.\n\n        The SATNUM = 2 is added to prosperities change. The idea is to have linear rel.perms to the second saturation table, so that \n        there will be least resistance for flow in the free pipe. \n\n        Then to mimic the pipe, there should be no flow on the side ways, therefore, the transmisibilities in the X and Y directions \n        in the edge of the pipe are set to zero. \n\n        Args:\n            ID (float): Internal Diameter (m)\n            x_min_pipe (int): minimum x\n            x_max_pipe (int): maximum x\n            y_min_pipe (int): minimum y\n            y_max_pipe (int): maximum y\n            k_min_pipe (int): minimum k of pipe\n            k_max_pipe (int): maximum k of pipe\n            k_min_hole (int): minimum k of open hole section\n            k_max_hole (int): maximum k of open hole section\n            perm (float): permeability value\n            LGR_NAME (str): LGR name\n            O (TextIO): opened file handle\n\n    \"\"\"\n\n    print ('EQUALS',file=O)\n\n    print ('--pipe with ID of',ID*39.37,'and perm of',perm,' were set in',LGR_NAME, 'Local Grid refinement',file=O)\n    print ('PERMX','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n    print ('PORO','','0.99','',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n    print ('SATNUM','',2,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n    print ('--FIPLEG (FIPNUM) defintion',file=O)\n    print ('FIPLEG','',6,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n\n    print ('--EQLNUM defintion',file=O)\n    print ('EQLNUM','',2,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_hole,'',k_max_hole,'','/',file=O)\n\n\n    print ('--Transmisibilities of the edge of the pipe set to zero',file=O)\n    print ('MULTX','',0,'',x_min_pipe-1,'',x_min_pipe-1,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTX','',0,'',x_max_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    # # TODO(hzh): Not sure about the next two lines of codes\n    # print ('MULTX','',0,'',x_min_pipe-1,'',x_max_pipe,'',y_min_pipe-1,'',y_min_pipe-1,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    # print ('MULTX','',0,'',x_min_pipe-1,'',x_max_pipe,'',y_max_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    print ('MULTY','',0,'',x_min_pipe-1,'',x_max_pipe,'',y_min_pipe-1,'',y_min_pipe-1,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTY','',0,'',x_min_pipe-1,'',x_max_pipe,'',y_max_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    # # TODO(hzh): Not sure about the next two lines of codes    \n    # print ('MULTY','',0,'',x_min_pipe-1,'',x_min_pipe-1,'',y_min_pipe-1,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    # print ('MULTY','',0,'',x_max_pipe,'',x_max_pipe,'',y_min_pipe-1,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    print ('/',file=O)</code></pre>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_pipe","title":"<code>src.GaP.libs.carfin.CARFIN_pipe</code>","text":"<p>pipe builder</p>"},{"location":"code_references/gap/gap_carfin/#src.GaP.libs.carfin.CARFIN_pipe.CARFIN_pipe","title":"<code>CARFIN_pipe(ID: float, x_min_pipe: int, x_max_pipe: int, y_min_pipe: int, y_max_pipe: int, k_min_pipe: int, k_max_pipe: int, perm: float, LGR_NAME: str, O: TextIO)</code>","text":"<p>CARFIN for pipe</p> <p>The pipes can be mimicked by a very narrow (in the size of ID of a pipe-20 to 50 cm) and high permeability grids.  Those grids could be surrounded by grids with zero transmissibility. </p> <p>Parameters:</p> <ul> <li> <code>ID</code>               (<code>float</code>)           \u2013            <p>Internal Diameter (m)</p> </li> <li> <code>x_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum x</p> </li> <li> <code>x_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum x</p> </li> <li> <code>y_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum y</p> </li> <li> <code>y_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum y</p> </li> <li> <code>k_min_pipe</code>               (<code>int</code>)           \u2013            <p>minimum k</p> </li> <li> <code>k_max_pipe</code>               (<code>int</code>)           \u2013            <p>maximum k</p> </li> <li> <code>perm</code>               (<code>float</code>)           \u2013            <p>permeability value</p> </li> <li> <code>LGR_NAME</code>               (<code>str</code>)           \u2013            <p>LGR name</p> </li> <li> <code>O</code>               (<code>TextIO</code>)           \u2013            <p>opened file handle</p> </li> </ul> Source code in <code>src/GaP/libs/carfin/CARFIN_pipe.py</code> <pre><code>def CARFIN_pipe(ID: float,\n                x_min_pipe: int, x_max_pipe: int,\n                y_min_pipe: int, y_max_pipe: int,\n                k_min_pipe: int, k_max_pipe: int,\n                perm: float,\n                LGR_NAME: str, \n                O: TextIO):  # noqa: E741\n    \"\"\" CARFIN for pipe\n\n        The pipes can be mimicked by a very narrow (in the size of ID of a pipe-20 to 50 cm) and high permeability grids. \n        Those grids could be surrounded by grids with zero transmissibility. \n\n        Args:\n            ID (float): Internal Diameter (m)\n            x_min_pipe (int): minimum x\n            x_max_pipe (int): maximum x\n            y_min_pipe (int): minimum y\n            y_max_pipe (int): maximum y\n            k_min_pipe (int): minimum k\n            k_max_pipe (int): maximum k\n            perm (float): permeability value\n            LGR_NAME (str): LGR name\n            O (TextIO): opened file handle\n    \"\"\"\n\n    print ('EQUALS',file=O)\n    print ('--pipe with ID of',ID*39.37,'and perm of',perm,' were set in',LGR_NAME, 'Local Grid refinement',file=O)\n    print ('PERMX','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('PERMY','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('PERMZ','',perm,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('PORO','','0.99','',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    print ('--Transmisibilities of the edge of the pipe set to zero',file=O)\n    print ('MULTX','',0,'',x_min_pipe,'',x_min_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTX','',0,'',x_max_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTX','',0,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_min_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTX','',0,'',x_min_pipe,'',x_max_pipe,'',y_max_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    print ('MULTY','',0,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_min_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTY','',0,'',x_min_pipe,'',x_max_pipe,'',y_max_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTY','',0,'',x_min_pipe,'',x_min_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('MULTY','',0,'',x_max_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n\n    print ('--New Saturation region for flow in pipe',file=O)\n    print ('SATNUM','',2,'',x_min_pipe,'',x_max_pipe,'',y_min_pipe,'',y_max_pipe,'',k_min_pipe,'',k_max_pipe,'','/',file=O)\n    print ('/',file=O)</code></pre>"},{"location":"code_references/gap/gap_geometry/","title":"Bounding boxes","text":""},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_barrier","title":"<code>src.GaP.libs.geometry.bbox_barrier</code>","text":"<p>barrier builder</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_barrier.bbox_for_barrier","title":"<code>bbox_for_barrier(cg: ElemModel, LGR_sizes_xy: List[float], LGR_depths: np.ndarray, min_grd_size: float) -&gt; Tuple</code>","text":"<p>build bouding box for barrier</p> <p>Parameters:</p> <ul> <li> <code>cg</code>               (<code>ElemModel</code>)           \u2013            <p>contains geometrical information of the casing</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <pre><code>tuple: the 3D bounding box and ID</code></pre> Source code in <code>src/GaP/libs/geometry/bbox_barrier.py</code> <pre><code>def bbox_for_barrier (cg: ElemModel, \n                      LGR_sizes_xy: List[float], \n                      LGR_depths: np.ndarray, \n                      min_grd_size: float) -&gt; Tuple:\n    \"\"\" build bouding box for barrier\n\n        Args:\n            cg (ElemModel): contains geometrical information of the casing\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            min_grd_size (float): minimum grid size\n\n        Returns:\n\n            tuple: the 3D bounding box and ID\n\n    \"\"\"\n\n    # for convenience\n    ID = cg.ID\n\n    # z\n    k_min_bar, k_max_bar = BBoxZ(cg.pipe.strt_depth, cg.pipe.end_depth, LGR_depths)\n\n    # x-y\n    x_min_bar, x_max_bar, y_min_bar, y_max_bar = BBoxXY(ID, LGR_sizes_xy, min_grd_size)\n\n    return ID, x_min_bar, x_max_bar, y_min_bar, y_max_bar, k_min_bar, k_max_bar</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_cement_bond","title":"<code>src.GaP.libs.geometry.bbox_cement_bond</code>","text":"<p>cemont bond builder</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_cement_bond.bbox_for_cement_bond","title":"<code>bbox_for_cement_bond(cg: PipeCementModel, LGR_sizes_xy: List[float], LGR_depths: np.ndarray, min_grd_size: float) -&gt; tuple</code>","text":"<p>build building box for cement bond</p> <p>Parameters:</p> <ul> <li> <code>cg</code>               (<code>PipeCementModel</code>)           \u2013            <p>contains geometrical information of the casing</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <pre><code>tuple: the 3D bounding box and ID</code></pre> Source code in <code>src/GaP/libs/geometry/bbox_cement_bond.py</code> <pre><code>def bbox_for_cement_bond(cg: PipeCementModel, \n                         LGR_sizes_xy: List[float], \n                         LGR_depths: np.ndarray, \n                         min_grd_size: float) -&gt; tuple:\n    \"\"\" build building box for cement bond\n\n        Args:\n            cg (PipeCementModel): contains geometrical information of the casing\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            min_grd_size (float): minimum grid size\n\n        Returns:\n\n            tuple: the 3D bounding box and ID\n    \"\"\"\n\n    # for convenience\n    ID = cg.ID\n\n    # z\n    k_min_CB, k_max_CB = BBoxZ(cg.cement.strt_depth, cg.cement.end_depth, LGR_depths)\n\n    # x-y bounding box\n    x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe = BBoxXY(ID, LGR_sizes_xy, min_grd_size)\n\n    return ID, x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe, k_min_CB, k_max_CB</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_pipe_with_oph_sec","title":"<code>src.GaP.libs.geometry.bbox_pipe_with_oph_sec</code>","text":"<p>pipe builder with open hole sections</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_pipe_with_oph_sec.bbox_for_pipe_with_oph_sec","title":"<code>bbox_for_pipe_with_oph_sec(cg: PipeCementModel, LGR_sizes_xy: List[float], LGR_depths: np.ndarray, min_grd_size: float) -&gt; tuple</code>","text":"<p>build bounding box for pipe with open hole sections</p> <p>Parameters:</p> <ul> <li> <code>cg</code>               (<code>PipeCementModel</code>)           \u2013            <p>contains geometrical information of the casing</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <pre><code>tuple: the 3D bounding box and min/max k hole and ID</code></pre> Source code in <code>src/GaP/libs/geometry/bbox_pipe_with_oph_sec.py</code> <pre><code>def bbox_for_pipe_with_oph_sec (cg: PipeCementModel,\n                                LGR_sizes_xy: List[float], \n                                LGR_depths: np.ndarray, \n                                min_grd_size: float) -&gt; tuple:\n    \"\"\" build bounding box for pipe with open hole sections\n\n        Args:\n            cg (PipeCementModel): contains geometrical information of the casing\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            min_grd_size (float): minimum grid size\n\n        Returns:\n\n            tuple: the 3D bounding box and min/max k hole and ID\n    \"\"\"\n\n    # for convenience\n    ID = cg.ID\n\n    # z, pipe\n    k_min_pipe, k_max_pipe = BBoxZ(cg.pipe.strt_depth, cg.pipe.end_depth, LGR_depths)\n\n    # z, open hole section\n    k_min_hole, k_max_hole = BBoxZ(cg.oph.strt_depth, cg.oph.end_depth, LGR_depths)\n\n    # x-y\n    x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe = BBoxXY(ID, LGR_sizes_xy, min_grd_size)\n\n    return ID, x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe, k_min_pipe, k_max_pipe, k_min_hole, k_max_hole</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_pipe","title":"<code>src.GaP.libs.geometry.bbox_pipe</code>","text":"<p>pipe builder</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_pipe.bbox_for_pipe","title":"<code>bbox_for_pipe(cg: PipeCementModel, LGR_sizes_xy: list[float], LGR_depths: np.ndarray, min_grd_size: float) -&gt; tuple</code>","text":"<p>build bounding box for the pipe</p> <p>Parameters:</p> <ul> <li> <code>cg</code>               (<code>PipeCementModel</code>)           \u2013            <p>contains geometrical information of the casing</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <pre><code>tuple: the 3D bounding box and ID</code></pre> Source code in <code>src/GaP/libs/geometry/bbox_pipe.py</code> <pre><code>def bbox_for_pipe (cg: PipeCementModel,\n                    LGR_sizes_xy: list[float], \n                    LGR_depths: np.ndarray, \n                    min_grd_size: float) -&gt; tuple:\n    \"\"\" build bounding box for the pipe\n\n        Args:\n            cg (PipeCementModel): contains geometrical information of the casing\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n            min_grd_size (float): minimum grid size\n\n        Returns:\n\n            tuple: the 3D bounding box and ID\n    \"\"\"\n\n    # for convenience\n    ID = cg.ID\n\n    # z\n    # pipe\n    k_min_pipe, k_max_pipe = BBoxZ(cg.pipe.strt_depth, cg.pipe.end_depth, LGR_depths)\n\n    # x-y\n    x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe = BBoxXY(ID, LGR_sizes_xy, min_grd_size)\n\n    return ID, x_min_pipe, x_max_pipe, y_min_pipe, y_max_pipe, k_min_pipe, k_max_pipe</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_utils","title":"<code>src.GaP.libs.geometry.bbox_utils</code>","text":"<p>compute bounding boxes for lateral x-y and depth z directions</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_utils.BBoxXY","title":"<code>BBoxXY(ID: float, LGR_sizes_xy: List[float], min_grd_size: float) -&gt; Tuple[int, int, int, int]</code>","text":"<p>Compute bounding box in x-y directions</p> <p>Parameters:</p> <ul> <li> <code>ID</code>               (<code>float</code>)           \u2013            <p>Internal diameter value</p> </li> <li> <code>LGR_sizes_xy</code>               (<code>list[float]</code>)           \u2013            <p>LGR xy grid intervals</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <pre><code>tuple: the 2D bounding box, indices, in lateral x-y plane of LGR grid</code></pre> Source code in <code>src/GaP/libs/geometry/bbox_utils.py</code> <pre><code>def BBoxXY(ID: float,\n            LGR_sizes_xy: List[float], \n            min_grd_size: float\n           ) -&gt; Tuple[int, int, int, int]:\n    \"\"\" Compute bounding box in x-y directions\n\n        Args:\n            ID (float): Internal diameter value\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n            min_grd_size (float): minimum grid size\n\n        Returns:\n\n            tuple: the 2D bounding box, indices, in lateral x-y plane of LGR grid\n    \"\"\"\n\n    # x\n    no_grd_elem_x = math.floor(ID/min_grd_size)\n\n    xa = (len (LGR_sizes_xy)-no_grd_elem_x)/2\n    if xa &lt; 0:\n        raise ValueError('ERROR:The ID of barrier is larger than refined area')\n\n    x_min_elem = math.ceil(xa)\n\n    x_max_elem = x_min_elem + no_grd_elem_x \n\n    # y\n    no_grd_elem_y = math.floor(ID/min_grd_size)\n\n    ya = (len (LGR_sizes_xy)-no_grd_elem_y)/2\n    if ya &lt; 0:\n        raise ValueError('ERROR:The ID of tube is larger than refined area')\n\n    y_min_elem = math.ceil(ya)\n\n    y_max_elem = y_min_elem + no_grd_elem_y \n\n    return x_min_elem, x_max_elem, y_min_elem, y_max_elem</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.bbox_utils.BBoxZ","title":"<code>BBoxZ(strt_depth: float, end_depth: float, LGR_depths: np.ndarray) -&gt; Tuple[int, int]</code>","text":"<p>Compute bounding box in z direction</p> <p>Parameters:</p> <ul> <li> <code>strt_depth</code>               (<code>float</code>)           \u2013            <p>start depth of element, such as pipe, cement-bond, or barrier</p> </li> <li> <code>end_depth</code>               (<code>float</code>)           \u2013            <p>end depth of element</p> </li> <li> <code>LGR_depths</code>               (<code>ndarray</code>)           \u2013            <p>specific size of each LGR grid in the Z direction</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code> (              <code>Tuple[int, int]</code> )          \u2013            <p>min/max z indices in LGR grid</p> </li> </ul> Source code in <code>src/GaP/libs/geometry/bbox_utils.py</code> <pre><code>def BBoxZ(strt_depth: float,\n          end_depth: float,\n          LGR_depths: np.ndarray\n          ) -&gt; Tuple[int, int]:\n    \"\"\" Compute bounding box in z direction\n\n        Args:\n            strt_depth (float): start depth of element, such as pipe, cement-bond, or barrier\n            end_depth (float): end depth of element\n            LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n\n        Returns:\n            tuple: min/max z indices in LGR grid\n    \"\"\"\n\n    # pipe\n    if (LGR_depths[0] - strt_depth) &gt; 0:\n        k_min_elem = 1 \n    else:\n        k_min_elem = np.argmin(abs(LGR_depths - strt_depth))+ 1 \n\n    if (LGR_depths[-1] - end_depth) &lt; 0:\n        k_max_elem =  len(LGR_depths)\n    else:\n        k_max_elem = np.argmin(abs(LGR_depths - end_depth))+ 1 \n\n    return k_min_elem, k_max_elem</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils","title":"<code>src.GaP.libs.geometry.LGR_grid_utils</code>","text":""},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils.compute_cement_bonds","title":"<code>compute_cement_bonds(cond_Casing_ID: float, surf_Casing_ID: float, prod_Casing_ID: float) -&gt; Tuple[float, float, float]</code>","text":"<p>compute cement bonds</p> Source code in <code>src/GaP/libs/geometry/LGR_grid_utils.py</code> <pre><code>def compute_cement_bonds(cond_Casing_ID: float, \n                         surf_Casing_ID: float, \n                         prod_Casing_ID: float) -&gt; Tuple[float, float, float]:\n    \"\"\" compute cement bonds\n    \"\"\"\n\n    # Calculating the size of grids for cement bond \n    # TODO(hzh): why multiply 2?\n    cond_bond = cond_Casing_ID - surf_Casing_ID*2\n    surf_bond = surf_Casing_ID - prod_Casing_ID\n    prod_bond = surf_Casing_ID - prod_Casing_ID\n\n    return cond_bond, surf_bond, prod_bond</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils.compute_min_grid_size","title":"<code>compute_min_grid_size(cond_Casing_ID: float, surf_Casing_ID: float, prod_Casing_ID: float) -&gt; float</code>","text":"<p>compute minimum grid size </p> <p>The min. sizes happen when pipes are going into each other:</p> <pre><code>From D&amp;W, we know some cosignings (if not all) have overlap with each other and that's why we have annules flow.\n\nIn addition, the thickness of the cement bond could be the difference between the casings.\n\nFinally, we don't want to go below 5cm grids, and above 25 cm is unphysically too large. Then we hard-code \nthe minim grid size to 10 cm in those case,\n\nOtherwise, let the code decide on the minimum grid size that we want to have.</code></pre> <p>Parameters:</p> <ul> <li> <code>cond_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of conductor casing</p> </li> <li> <code>surf_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of surface casing</p> </li> <li> <code>prod_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of production casing</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>minimum grid size</p> </li> </ul> Source code in <code>src/GaP/libs/geometry/LGR_grid_utils.py</code> <pre><code>def compute_min_grid_size(cond_Casing_ID: float, \n                          surf_Casing_ID: float, \n                          prod_Casing_ID: float) -&gt; float:\n    \"\"\" compute minimum grid size \n\n    The min. sizes happen when pipes are going into each other:\n\n        From D&amp;W, we know some cosignings (if not all) have overlap with each other and that's why we have annules flow. \n\n        In addition, the thickness of the cement bond could be the difference between the casings. \n\n        Finally, we don't want to go below 5cm grids, and above 25 cm is unphysically too large. Then we hard-code \n        the minim grid size to 10 cm in those case,\n\n        Otherwise, let the code decide on the minimum grid size that we want to have. \n\n    Args:\n        cond_Casing_ID (float): ID of conductor casing\n        surf_Casing_ID (float): ID of surface casing\n        prod_Casing_ID (float): ID of production casing\n\n    Returns:\n        float: minimum grid size\n    \"\"\"\n\n    # Conversion of Casing diameter to cartesian system \n    # dimensions for casings\n    case_dim = [np.sqrt(0.25*np.pi*cond_Casing_ID**2),\n                np.sqrt(0.25*np.pi*surf_Casing_ID**2), \n                np.sqrt(0.25*np.pi*prod_Casing_ID**2)]\n\n\n    # dimensions for cement bonds\n    bond_dim = compute_cement_bonds(cond_Casing_ID, \n                                    surf_Casing_ID, \n                                    prod_Casing_ID)\n\n    # compute the min grid size\n    if round (min(case_dim + bond_dim), 2) &lt; 0.05 or round(min(case_dim + bond_dim), 2) &gt; 0.25:\n        min_grd_size = 0.1 #round (min(case_dim + bond_dim),2)\n    else: \n        min_grd_size = round (min(case_dim + bond_dim), 2)\n\n    return min_grd_size</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils.compute_max_num_of_fine_grid_xy","title":"<code>compute_max_num_of_fine_grid_xy(cond_Casing_ID: float, surf_Casing_ID: float, prod_Casing_ID: float, min_grd_size: float) -&gt; int</code>","text":"<p>compute maximum number of the fine grid in x-y direction</p> <p>For each casing we have its ID , therefore, the number of grids for each casing we should have round up casing_ID/min_grd_size.</p> <p>From the thickness of the cement bond, accordingly we can assume how many grids do we want that for this. </p> <p>Then, per casing the total number of grids = number of grids to mimic the pipe + 2 x number of grids for the cement bond. </p> <p>Parameters:</p> <ul> <li> <code>cond_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of conductor casing</p> </li> <li> <code>surf_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of surface casing</p> </li> <li> <code>prod_Casing_ID</code>               (<code>float</code>)           \u2013            <p>ID of production casing</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LGR_sizes_xy</code> (              <code>list[float]</code> )          \u2013            <p>LGR xy grid intervals</p> </li> </ul> Source code in <code>src/GaP/libs/geometry/LGR_grid_utils.py</code> <pre><code>def compute_max_num_of_fine_grid_xy(cond_Casing_ID: float, \n                                    surf_Casing_ID: float, \n                                    prod_Casing_ID: float, \n                                    min_grd_size: float) -&gt; int:\n    \"\"\" compute maximum number of the fine grid in x-y direction\n\n        For each casing we have its ID , therefore, the number of grids for each casing we should have round up casing_ID/min_grd_size.\n\n        From the thickness of the cement bond, accordingly we can assume how many grids do we want that for this. \n\n        Then, per casing the total number of grids = number of grids to mimic the pipe + 2 x number of grids for the cement bond. \n\n        Args:\n            cond_Casing_ID (float): ID of conductor casing\n            surf_Casing_ID (float): ID of surface casing\n            prod_Casing_ID (float): ID of production casing\n            min_grd_size (float): minimum grid size\n\n        Returns:\n            LGR_sizes_xy (list[float]): LGR xy grid intervals\n    \"\"\"\n\n    # Calculating the size of grids for cement bond \n    cond_bond, surf_bond, prod_bond = compute_cement_bonds(cond_Casing_ID, \n                                                            surf_Casing_ID, \n                                                            prod_Casing_ID)\n\n    # Number of refined grids in tubes and cement bonds\n\n    # 1. tubes\n    no_grd_cond_case = math.ceil(cond_Casing_ID/min_grd_size)\n    no_grd_surf_case = math.ceil(surf_Casing_ID/min_grd_size)\n    no_grd_prod_case = math.ceil(prod_Casing_ID/min_grd_size)\n\n    # 2. cement bonds\n    no_grd_cond_bond = math.ceil(cond_bond/min_grd_size)\n    no_grd_surf_bond = math.ceil(surf_bond/min_grd_size)\n    no_grd_prod_bond = math.ceil(prod_bond/min_grd_size)\n\n    # 3. TODO(hzh): why add them together and why multiply 2?\n    no_latral_grd_cond = no_grd_cond_case + no_grd_cond_bond*2\n    no_latral_grd_surf = no_grd_surf_case + no_grd_surf_bond*2\n    no_latral_grd_prod = no_grd_prod_case + no_grd_prod_bond*2\n\n    # print('ooooo', cond_bond, surf_bond, prod_bond)\n    # print('xxxxx', no_latral_grd_cond, no_latral_grd_surf, no_latral_grd_prod)\n    # print('yyyyy', no_grd_cond_case, no_grd_surf_case, no_grd_prod_bond)\n\n    # 4. find maximum of the three\n    no_latral_fine_grd = max(no_latral_grd_cond, no_latral_grd_surf, no_latral_grd_prod)\n\n    return no_latral_fine_grd</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils.compute_LGR_xy","title":"<code>compute_LGR_xy(no_latral_fine_grd: int, main_grd_dx: float, min_grd_size: float) -&gt; List[float]</code>","text":"<p>LGR grid list in x-y direction</p> <p>Thinking laterally we need ones to the right and one to the left</p> <p>Parameters:</p> <ul> <li> <code>no_latral_fine_grd</code>               (<code>int</code>)           \u2013            <p>number of LGR lateral fine grids, including casing and cement bond</p> </li> <li> <code>main_grd_dx</code>               (<code>float</code>)           \u2013            <p>DX value on coarse grid at the well location</p> </li> <li> <code>min_grd_size</code>               (<code>float</code>)           \u2013            <p>minimum grid size</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LGR_sizes_xy</code> (              <code>list[float]</code> )          \u2013            <p>LGR xy grid interval values</p> </li> </ul> Source code in <code>src/GaP/libs/geometry/LGR_grid_utils.py</code> <pre><code>def compute_LGR_xy(no_latral_fine_grd: int, \n                   main_grd_dx: float, \n                   min_grd_size: float) -&gt; List[float]:\n    \"\"\" LGR grid list in x-y direction\n\n        Thinking laterally we need ones to the right and one to the left\n\n        Args:\n            no_latral_fine_grd (int): number of LGR lateral fine grids, including casing and cement bond\n            main_grd_dx (float): DX value on coarse grid at the well location\n            min_grd_size (float): minimum grid size\n\n        Returns:\n            LGR_sizes_xy (list[float]): LGR xy grid interval values\n    \"\"\"\n\n    # # the fine grid\n    # LGR_size_fine_grd = [min_grd_size]*no_latral_fine_grd\n\n    # 5. the list\n    # add transistion zone between coarse and fine grids\n    LGR_size_no_outer = [min_grd_size*100] + \\\n                        [min_grd_size*10] + \\\n                        [min_grd_size] * no_latral_fine_grd + \\\n                        [min_grd_size*10] + \\\n                        [min_grd_size*100]\n\n    # 6. LGR_sizes_xy, adding dx on both sides to make it one cell size\n    LGR_sizes_xy = [(main_grd_dx - sum(LGR_size_no_outer))/2] + LGR_size_no_outer + [(main_grd_dx - sum(LGR_size_no_outer))/2]\n\n    return LGR_sizes_xy</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid_utils.compute_LGR_z","title":"<code>compute_LGR_z(main_DZ, ref_depth, main_grd_min_k, main_grd_max_k, no_of_layers_in_OB) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>LGR grid in z direction</p> <p>The idea is not to refine too much in the Z direction, mainly because of the computational time. </p> <p>However, it we don't refine at all, the resolution in the Z direction in overburden might be too low. Then, it would limit  our access to a specific depth, when we want to set start and end depth of each casing. </p> <p>First we define how many grids do we want? </p> <pre><code>We hard-coded the number of grids in overburden to 10 per layer. i.e. each layer is refined into 10 layers. \nFor example, if we have 5 coarse grids in the overburden, in the LGR we will have 5x10=50 layers.\n\nThen we convert the list to numpy array to be able to do calculation on that.\n\nLater we will see the LGR_numb_z can directly be used in the NZFIN keyword under CARFIN</code></pre> <p>Parameters:</p> <ul> <li> <code>main_DZ</code>               (<code>ndarray</code>)           \u2013            <p>thickness or interval of each layer (coarse grid)</p> </li> <li> <code>main_grd_min_k</code>               (<code>int</code>)           \u2013            <p>minimum z index (coarse grid)</p> </li> <li> <code>main_grd_max_k</code>               (<code>int</code>)           \u2013            <p>maximum z index (coarse grid)</p> </li> <li> <code>no_of_layers_in_OB</code>               (<code>int</code>)           \u2013            <p>number of layers in Overburden (coarse grid)</p> </li> </ul> <p>Returns:</p> <pre><code>LGR_depths (np.ndarray): depth values of each LGR z \nLGR_numb_z (np.ndarray): number of refined layers in each coarse layer</code></pre> Source code in <code>src/GaP/libs/geometry/LGR_grid_utils.py</code> <pre><code>def compute_LGR_z(main_DZ,\n                    ref_depth,\n                    main_grd_min_k, main_grd_max_k, \n                    no_of_layers_in_OB) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\" LGR grid in z direction\n\n    The idea is not to refine too much in the Z direction, mainly because of the computational time. \n\n    However, it we don't refine at all, the resolution in the Z direction in overburden might be too low. Then, it would limit \n    our access to a specific depth, when we want to set start and end depth of each casing. \n\n    First we define how many grids do we want? \n\n        We hard-coded the number of grids in overburden to 10 per layer. i.e. each layer is refined into 10 layers. \n        For example, if we have 5 coarse grids in the overburden, in the LGR we will have 5x10=50 layers. \n\n        Then we convert the list to numpy array to be able to do calculation on that.\n\n        Later we will see the LGR_numb_z can directly be used in the NZFIN keyword under CARFIN  \n\n    Args:\n        main_DZ (np.ndarray): thickness or interval of each layer (coarse grid)\n        main_grd_min_k (int): minimum z index (coarse grid)\n        main_grd_max_k (int): maximum z index (coarse grid)\n        no_of_layers_in_OB (int): number of layers in Overburden (coarse grid)\n\n    Returns:\n\n        LGR_depths (np.ndarray): depth values of each LGR z \n        LGR_numb_z (np.ndarray): number of refined layers in each coarse layer        \n    \"\"\"\n\n    #all Z grids in OB is devided into 10 grids (hard coded), grids in reservoir remained unchanged\n\n    #LGR_numb_z = (no_of_layers_in_OB-main_grd_min_k + 1) * [10] + (main_grd_max_k - main_grd_min_k + 1 -(no_of_layers_in_OB-main_grd_min_k+1) ) *[1] \n\n    # TODO(hzh): the number 10 is hard-coded?\n    # refine only coarse grid in ovb, and keep reservoir grid unchanged\n    LGR_numb_z = (no_of_layers_in_OB - main_grd_min_k + 1) * [10] + (main_grd_max_k - no_of_layers_in_OB) * [1] \n    LGR_numb_z = np.array(LGR_numb_z)\n\n    #\n    assert LGR_numb_z.size == main_DZ.size, 'dimension should match'\n    # **** LGR_size_z\n    LGR_size_z = np.divide(main_DZ, LGR_numb_z)\n\n    # \n    LGR_intvl  = np.zeros((LGR_numb_z.sum(),0))\n    # LGR_depths = np.zeros((LGR_numb_z.sum(),0))\n\n    # LGR_index_z = np.arange(1, LGR_numb_z.sum()+1)\n\n    for i in range (0, LGR_numb_z.shape[0]): \n        LGR_intvl= np.append(LGR_intvl, np.repeat(LGR_size_z[i], LGR_numb_z[i]))\n\n    # Depth conversion from field to metric. sample .EGRID model is in Field unit\n    # TODO(hzh): why add ref_depth?\n    LGR_intvl [0] = LGR_intvl[0] + ref_depth\n    LGR_depths = (np.cumsum(LGR_intvl))\n\n    # main_DZ[0] = ref_depth + main_DZ[0]\n    # MAIN_depths = (np.cumsum (main_DZ))\n\n    return LGR_depths, LGR_numb_z</code></pre>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid","title":"<code>src.GaP.libs.geometry.LGR_grid</code>","text":"<p>generate fine grid from well casing geometries</p>"},{"location":"code_references/gap/gap_geometry/#src.GaP.libs.geometry.LGR_grid.generate_LGR_grids","title":"<code>generate_LGR_grids(casing_IDs: List[float], main_grd_dx, main_DZ, ref_depth: float, main_grd_min_k: int, main_grd_max_k: int, no_of_layers_in_OB: int, use_default_grid_size=True) -&gt; Tuple[List[float], np.ndarray, np.ndarray, float]</code>","text":"<p>generate LGR grid information</p> <p>Args:</p> <pre><code>casing_IDs (list[float]): list of IDs of conductor, surface and production\nmain_grd_dx (float): dx for the cell (coarse grid) at the well location \nmain_DZ (np.ndarray): thickness of each layer in the Z direction (coarse grid)\nmain_grd_min_k (int): minimum z index (coarse grid)\nmain_grd_max_k (int): maximum z index (coarse grid)\nno_of_layers_in_OB (int): number of layers in Overburden\nuse_default_grid_size (bool): flag for using default grid size, which is 5cm</code></pre> <p>Returns:</p> <pre><code>LGR_sizes_xy (list[float]): LGR xy grid intervals\nLGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\nLGR_numb_z (np.ndarray): number of chops for each main DZ\nmin_grd_size (float): minimum dz value (LGR grid)</code></pre> Source code in <code>src/GaP/libs/geometry/LGR_grid.py</code> <pre><code>def generate_LGR_grids(casing_IDs: List[float],\n                        main_grd_dx, main_DZ,\n                        ref_depth: float,\n                        main_grd_min_k: int, main_grd_max_k: int, \n                        no_of_layers_in_OB: int,\n                        use_default_grid_size=True) -&gt; Tuple[List[float], np.ndarray, np.ndarray, float]:\n    \"\"\" generate LGR grid information\n\n    Args:\n\n        casing_IDs (list[float]): list of IDs of conductor, surface and production\n        main_grd_dx (float): dx for the cell (coarse grid) at the well location \n        main_DZ (np.ndarray): thickness of each layer in the Z direction (coarse grid)\n        main_grd_min_k (int): minimum z index (coarse grid)\n        main_grd_max_k (int): maximum z index (coarse grid)\n        no_of_layers_in_OB (int): number of layers in Overburden\n        use_default_grid_size (bool): flag for using default grid size, which is 5cm \n\n    Returns:\n\n        LGR_sizes_xy (list[float]): LGR xy grid intervals\n        LGR_depths (np.ndarray): specific size of each LGR grid in the Z direction\n        LGR_numb_z (np.ndarray): number of chops for each main DZ\n        min_grd_size (float): minimum dz value (LGR grid)\n    \"\"\"\n\n    # for convenience\n    cond_Casing_ID = casing_IDs[0]\n    surf_Casing_ID = casing_IDs[1]\n    prod_Casing_ID = casing_IDs[2]\n\n    # 0. grid size for fine grid\n    if use_default_grid_size:\n\n        # TODO(hzh): fixed value???????\n        min_grd_size = 0.05\n\n    else:\n        # compute min grid size\n        min_grd_size = compute_min_grid_size(cond_Casing_ID, \n                                             surf_Casing_ID, \n                                             prod_Casing_ID)\n\n    # 1. number of fine grids for the well core\n    no_latral_fine_grd = compute_max_num_of_fine_grid_xy(cond_Casing_ID, \n                                                         surf_Casing_ID, \n                                                         prod_Casing_ID, \n                                                         min_grd_size)\n    # 2. refine grid in x-y directions\n    LGR_sizes_xy = compute_LGR_xy(no_latral_fine_grd, \n                                    main_grd_dx,\n                                    min_grd_size)\n\n    # 3. refine grid in z direction\n    LGR_depths, LGR_numb_z = compute_LGR_z(main_DZ,\n                                            ref_depth,\n                                            main_grd_min_k, main_grd_max_k, \n                                            no_of_layers_in_OB)\n\n    return LGR_sizes_xy, LGR_depths, LGR_numb_z, min_grd_size</code></pre>"},{"location":"code_references/well_class/grids/","title":"Various grids","text":""},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_coarse","title":"<code>src.WellClass.libs.grid_utils.grid_coarse</code>","text":""},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_coarse.GridCoarse","title":"<code>GridCoarse</code>","text":"Source code in <code>src/WellClass/libs/grid_utils/grid_coarse.py</code> <pre><code>class GridCoarse:\n\n    def __init__(self, simcase: str):\n        \"\"\" Loading the model\n\n             - Load the PFT grid, init and restart files\n\n             - Grid contains geometry specs\n\n             - INIT contains static properties (i.e. poro., perm., transmissibilities)\n\n             - RST contains dynamic properties (i.e. saturations, pressure)\n\n            Args:\n                simcase (str): name prefix for ECL grid\n        \"\"\"\n\n        #Get grid dimensions and coordinates\n        grid = EclGrid(simcase + \".EGRID\") \n        #init = EclGrid(simcase + \".INIT\") \n        init = EclInitFile(grid, simcase + \".INIT\")\n        # restart file\n        # rst = EclRestartFile(grid, simcase + \".UNRST\")\n\n        # ## The grid dimensions\n        self.NX, self.NY, self.NZ, _ = grid.get_dims()\n\n        print(f'Coarse grid dimension: nx={self.NX}, ny={self.NY}, nz={self.NZ}')\n\n        # # Store INIT parameters into a Pandas Dataframe: grid_init\n\n        self.grid_init = grid.export_index()\n\n        # Static properties Dataframe\n        for key in init.keys():\n                try:\n                        self.grid_init[key] = init[key][0].numpy_view()\n                except Exception:\n                        continue\n\n        # set up other grid-related information\n        self._set_grid_info(self.grid_init)\n\n        # set up cell coordinates\n        self._set_cell_coords(self.grid_init)\n\n    def _set_cell_coords(self, grid_init: pd.DataFrame):\n        \"\"\" Create cell coordinate X, Y, Z\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n        \"\"\"\n\n        # generate cell coordinates by shifting half cell size\n        xcoord = (grid_init.query(\"j==0&amp;k==0\").DX.cumsum() - grid_init.query(\"j==0&amp;k==0\").DX/2).values\n        ycoord = (grid_init.query(\"i==0&amp;k==0\").DY.cumsum() - grid_init.query(\"i==0&amp;k==0\").DY/2).values\n        zcoord = (grid_init.query(\"i==0&amp;j==0\").DZ.cumsum() - grid_init.query(\"i==0&amp;j==0\").DZ/2).values\n\n        # TODO(hzh): a bug?\n        # map_X = dict(zip(grid_init.query(\"j==0&amp;j==0\")['i'], xcoord))\n        map_X = dict(zip(grid_init.query(\"j==0&amp;k==0\")['i'], xcoord))\n        map_Y = dict(zip(grid_init.query(\"i==0&amp;k==0\")['j'], ycoord))\n        map_Z = dict(zip(grid_init.query(\"i==0&amp;j==0\")['k'], zcoord))\n\n        # save cell coordinates to DataFrame\n        grid_init['X'] = grid_init['i'].map(map_X)\n        grid_init['Y'] = grid_init['j'].map(map_Y)\n        grid_init['Z'] = grid_init['k'].map(map_Z)\n\n        # mid values\n        mid_i = self.main_grd_i\n        mid_j = self.main_grd_j\n\n        self.xcoord0 = xcoord[mid_i]\n        self.ycoord0 = ycoord[mid_j]\n\n    def _set_grid_info(self, grid_init: pd.DataFrame):\n        \"\"\" Grid information for coarse grid\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n        \"\"\"\n\n        # Retrieve coarse x-y grid indexes where LGR will be placed\n        # i.e., center grid\n        self.main_grd_i = grid_init.i.max()//2\n        self.main_grd_j = grid_init.j.max()//2\n\n        # Rettrieve min and max k-index for column where LGR will be placed\n        self.main_grd_min_k = grid_init.k.min()\n        self.main_grd_max_k = grid_init.k.max()\n\n        # Retrieve coarse cell sizes\n        self._set_main_grd_dx_dy(grid_init, self.main_grd_i, self.main_grd_j)\n\n        # Retrieve refdepth where LGR starts\n        self._set_ref_depth(grid_init, self.main_grd_i, self.main_grd_j)\n\n        # Retrieve number of cells representing water column and overburden\n        self._set_no_layers(grid_init, self.main_grd_i, self.main_grd_j)\n\n        self._set_DZ_rsrv_ovb(grid_init, self.main_grd_i, self.main_grd_j)\n\n    def _set_main_grd_dx_dy(self, \n                            grid_init: pd.DataFrame, \n                            main_grd_i: int, \n                            main_grd_j: int):\n        \"\"\" coarse cell size at the center grid\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n                main_grd_i (int): index of center x grid\n                main_grd_j (int): index of center y grid\n        \"\"\"\n\n        self.main_grd_dx = grid_init.query('i == @main_grd_i &amp; j == @main_grd_j &amp; k == k.min()')['DX'].iloc[0]\n        self.main_grd_dy = grid_init.query('i == @main_grd_i &amp; j == @main_grd_j &amp; k == k.min()')['DY'].iloc[0]\n\n    def _set_ref_depth(self, \n                        grid_init: pd.DataFrame, \n                        main_grd_i: int, \n                        main_grd_j: int):\n        \"\"\" set reference depth for LGR grid\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n                main_grd_i (int): index of center x grid\n                main_grd_j (int): index of center y grid\n        \"\"\"\n\n        # Retrieve all DZ in coarse grid, not used\n        main_DZ    = grid_init.query('i == @main_grd_i &amp; j == @main_grd_j')['DZ'].values\n\n        main_DEPTH = grid_init.query('i == @main_grd_i &amp; j == @main_grd_j')['DEPTH'].values\n\n        # depth where LGR starts\n        self.ref_depth = main_DEPTH[0] - 0.5*main_DZ[0]\n\n    def _set_no_layers(self, \n                        grid_init: pd.DataFrame, \n                        main_grd_i: int, \n                        main_grd_j: int):\n        \"\"\" Retrieve number of cells representing water column and overburden\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n                main_grd_i (int): index of center x grid\n                main_grd_j (int): index of center y grid\n        \"\"\"\n\n        self.no_of_layers_in_OB    = grid_init.query('i==@main_grd_i &amp; j == @main_grd_j &amp; DZ &gt;  10')['DZ'].shape[0]\n        self.no_of_layers_below_OB = grid_init.query('i==@main_grd_i &amp; j == @main_grd_j &amp; DZ &lt;= 10')['DZ'].shape[0]\n\n    def _set_DZ_rsrv_ovb(self, \n                         grid_init: pd.DataFrame, \n                         main_grd_i: int, \n                         main_grd_j: int, \n                         dz0: Union[float, int] =10):\n        \"\"\" DZs for rsrv and ovb\n\n            Args:\n                grid_init (pd.DataFrame): dataframe containing coarse grid information\n                main_grd_i (int): index of center x grid\n                main_grd_j (int): index of center y grid\n                dz0 (float): the dz value to distinguish zones between reservoir and ovb\n        \"\"\"\n\n        # 3.1 DZs for reservoir\n        self.DZ_rsrv = grid_init.query('i==@main_grd_i &amp; j == @main_grd_j &amp; DZ &lt;= @dz0')['DZ'].values\n\n        # 3.2 DZs for coarse grid\n        self.DZ_ovb_coarse = grid_init.query('i==@main_grd_i &amp; j == @main_grd_j &amp; DZ &gt; @dz0')['DZ'].values\n\n\n    def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\" generate xcorn and zcorn coordinates\n        \"\"\"\n\n        # for convenience\n        grid_init = self.grid_init\n\n        # shift grid coordinates half-length in x-y directions, i.e., [0, 3900] =&gt; [-1900, 2100]\n        # but not in z direction\n        sDX = self.xcoord0\n        sDY = self.ycoord0\n\n        # generate grid coordinates for plotting\n        xcorn, zcorn = extract_xz_corn_coords(grid_init, sDX, sDY)\n\n        return xcorn, zcorn \n\n    def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n        \"\"\" generate x-z PERM slice\n\n            Args:\n                prop (str): the property name, default: PERMX\n\n            Returns:\n                np.ndarray: x-z slice of the property\n        \"\"\"\n        # for convenience\n        grid_init = self.grid_init\n\n        # extract permeability\n        Z = extract_xz_prop_slice(grid_init, prop=prop)\n\n        return Z</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_coarse.GridCoarse.__init__","title":"<code>__init__(simcase: str)</code>","text":"<p>Loading the model</p> <ul> <li> <p>Load the PFT grid, init and restart files</p> </li> <li> <p>Grid contains geometry specs</p> </li> <li> <p>INIT contains static properties (i.e. poro., perm., transmissibilities)</p> </li> <li> <p>RST contains dynamic properties (i.e. saturations, pressure)</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>simcase</code>               (<code>str</code>)           \u2013            <p>name prefix for ECL grid</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_coarse.py</code> <pre><code>def __init__(self, simcase: str):\n    \"\"\" Loading the model\n\n         - Load the PFT grid, init and restart files\n\n         - Grid contains geometry specs\n\n         - INIT contains static properties (i.e. poro., perm., transmissibilities)\n\n         - RST contains dynamic properties (i.e. saturations, pressure)\n\n        Args:\n            simcase (str): name prefix for ECL grid\n    \"\"\"\n\n    #Get grid dimensions and coordinates\n    grid = EclGrid(simcase + \".EGRID\") \n    #init = EclGrid(simcase + \".INIT\") \n    init = EclInitFile(grid, simcase + \".INIT\")\n    # restart file\n    # rst = EclRestartFile(grid, simcase + \".UNRST\")\n\n    # ## The grid dimensions\n    self.NX, self.NY, self.NZ, _ = grid.get_dims()\n\n    print(f'Coarse grid dimension: nx={self.NX}, ny={self.NY}, nz={self.NZ}')\n\n    # # Store INIT parameters into a Pandas Dataframe: grid_init\n\n    self.grid_init = grid.export_index()\n\n    # Static properties Dataframe\n    for key in init.keys():\n            try:\n                    self.grid_init[key] = init[key][0].numpy_view()\n            except Exception:\n                    continue\n\n    # set up other grid-related information\n    self._set_grid_info(self.grid_init)\n\n    # set up cell coordinates\n    self._set_cell_coords(self.grid_init)</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_coarse.GridCoarse.extract_xz_corn_coords","title":"<code>extract_xz_corn_coords() -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>generate xcorn and zcorn coordinates</p> Source code in <code>src/WellClass/libs/grid_utils/grid_coarse.py</code> <pre><code>def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\" generate xcorn and zcorn coordinates\n    \"\"\"\n\n    # for convenience\n    grid_init = self.grid_init\n\n    # shift grid coordinates half-length in x-y directions, i.e., [0, 3900] =&gt; [-1900, 2100]\n    # but not in z direction\n    sDX = self.xcoord0\n    sDY = self.ycoord0\n\n    # generate grid coordinates for plotting\n    xcorn, zcorn = extract_xz_corn_coords(grid_init, sDX, sDY)\n\n    return xcorn, zcorn </code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_coarse.GridCoarse.extract_xz_slice","title":"<code>extract_xz_slice(prop='PERMX') -&gt; np.ndarray</code>","text":"<p>generate x-z PERM slice</p> <p>Parameters:</p> <ul> <li> <code>prop</code>               (<code>str</code>, default:                   <code>'PERMX'</code> )           \u2013            <p>the property name, default: PERMX</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: x-z slice of the property</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_coarse.py</code> <pre><code>def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n    \"\"\" generate x-z PERM slice\n\n        Args:\n            prop (str): the property name, default: PERMX\n\n        Returns:\n            np.ndarray: x-z slice of the property\n    \"\"\"\n    # for convenience\n    grid_init = self.grid_init\n\n    # extract permeability\n    Z = extract_xz_prop_slice(grid_init, prop=prop)\n\n    return Z</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine","title":"<code>src.WellClass.libs.grid_utils.grid_refine</code>","text":""},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine.GridRefine","title":"<code>GridRefine</code>","text":"<p>               Bases: <code>GridRefineBase</code></p> Source code in <code>src/WellClass/libs/grid_utils/grid_refine.py</code> <pre><code>class GridRefine(GridRefineBase):\n\n    def __init__(self, \n                 grid_coarse: GridCoarse,\n                 LGR_sizes_x: List[float], \n                 LGR_sizes_y: List[float], \n                 LGR_sizes_z: np.ndarray,\n                 min_grd_size: float):\n        \"\"\" class for LGR mesh for the center coarse cell\n\n            Args:\n\n                grid_coarse (GridCoarse): information on coarse grid\n                LGR_sizes_x (list[float]): LGR x grid intervals\n                LGR_sizes_y (list[float]): LGR y grid intervals\n                LGR_sizes_z (np.ndarray): LGR DZ inernals\n                min_grd_size (float): minimize grid size\n        \"\"\"\n\n        super().__init__(grid_coarse, \n                         LGR_sizes_x, LGR_sizes_y, LGR_sizes_z,\n                         min_grd_size)\n\n    # TODO(hzh): Here the input will be modified. \n    # This is not a good practice of programming!!! \n    # Will come back to this.\n    def build_LGR(self, \n                  drilling_df: pd.DataFrame, \n                  casings_df: pd.DataFrame, \n                  barriers_mod_df: pd.DataFrame) -&gt; None:\n        \"\"\" assign material types to corresponding permeabilities.\n\n            Args:\n\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier \n\n            Returns:\n                an updated dataframe specifically for GaP code                 \n        \"\"\"\n\n        # 1. compute lateral number of refined grid\n        self._compute_num_lateral_fine_grd(drilling_df, casings_df, barriers_mod_df)\n\n        # 2. set bounding box\n        self._compute_bbox(drilling_df, casings_df, barriers_mod_df)\n\n        # 3. set material type\n        self._set_material_type(drilling_df, casings_df, barriers_mod_df)\n\n        # 4. set permeability\n        self._set_permeability(drilling_df, casings_df, barriers_mod_df)\n\n        # 0. for GaP code\n        gap_casing_df = self._compute_bbox_gap_casing(casings_df)\n\n        return gap_casing_df\n\n    def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\" generate xcorn and zcorn coordinates\n        \"\"\"\n\n        # for convenience\n        mesh_df = self.mesh_df\n\n        # for shifting\n        sDX = self.main_grd_dx/2\n        sDY = self.main_grd_dy/2\n\n        # generate grid coordinates for plotting\n        xcorn, zcorn = extract_xz_corn_coords(mesh_df, sDX, sDY)\n\n        return xcorn, zcorn\n\n    def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n        \"\"\" generate x-z PERM slice\n\n            Args:\n                prop (str): the property name, default: PERMX\n\n            Returns:\n                np.ndarray: x-z slice of the property\n        \"\"\"\n        # for convenience\n        mesh_df = self.mesh_df\n\n        # extract permeability\n        Z = extract_xz_prop_slice(mesh_df, prop=prop)\n\n        return Z </code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine.GridRefine.__init__","title":"<code>__init__(grid_coarse: GridCoarse, LGR_sizes_x: List[float], LGR_sizes_y: List[float], LGR_sizes_z: np.ndarray, min_grd_size: float)</code>","text":"<p>class for LGR mesh for the center coarse cell</p> <p>Args:</p> <pre><code>grid_coarse (GridCoarse): information on coarse grid\nLGR_sizes_x (list[float]): LGR x grid intervals\nLGR_sizes_y (list[float]): LGR y grid intervals\nLGR_sizes_z (np.ndarray): LGR DZ inernals\nmin_grd_size (float): minimize grid size</code></pre> Source code in <code>src/WellClass/libs/grid_utils/grid_refine.py</code> <pre><code>def __init__(self, \n             grid_coarse: GridCoarse,\n             LGR_sizes_x: List[float], \n             LGR_sizes_y: List[float], \n             LGR_sizes_z: np.ndarray,\n             min_grd_size: float):\n    \"\"\" class for LGR mesh for the center coarse cell\n\n        Args:\n\n            grid_coarse (GridCoarse): information on coarse grid\n            LGR_sizes_x (list[float]): LGR x grid intervals\n            LGR_sizes_y (list[float]): LGR y grid intervals\n            LGR_sizes_z (np.ndarray): LGR DZ inernals\n            min_grd_size (float): minimize grid size\n    \"\"\"\n\n    super().__init__(grid_coarse, \n                     LGR_sizes_x, LGR_sizes_y, LGR_sizes_z,\n                     min_grd_size)</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine.GridRefine.build_LGR","title":"<code>build_LGR(drilling_df: pd.DataFrame, casings_df: pd.DataFrame, barriers_mod_df: pd.DataFrame) -&gt; None</code>","text":"<p>assign material types to corresponding permeabilities.</p> <p>Args:</p> <pre><code>drilling_df (pd.DataFrame): information about drilling\ncasings_df (pd.DataFrame): information about casings and cement-bond\nbarriers_mod_df (pd.DataFrame): information about barrier</code></pre> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>an updated dataframe specifically for GaP code</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_refine.py</code> <pre><code>def build_LGR(self, \n              drilling_df: pd.DataFrame, \n              casings_df: pd.DataFrame, \n              barriers_mod_df: pd.DataFrame) -&gt; None:\n    \"\"\" assign material types to corresponding permeabilities.\n\n        Args:\n\n            drilling_df (pd.DataFrame): information about drilling\n            casings_df (pd.DataFrame): information about casings and cement-bond\n            barriers_mod_df (pd.DataFrame): information about barrier \n\n        Returns:\n            an updated dataframe specifically for GaP code                 \n    \"\"\"\n\n    # 1. compute lateral number of refined grid\n    self._compute_num_lateral_fine_grd(drilling_df, casings_df, barriers_mod_df)\n\n    # 2. set bounding box\n    self._compute_bbox(drilling_df, casings_df, barriers_mod_df)\n\n    # 3. set material type\n    self._set_material_type(drilling_df, casings_df, barriers_mod_df)\n\n    # 4. set permeability\n    self._set_permeability(drilling_df, casings_df, barriers_mod_df)\n\n    # 0. for GaP code\n    gap_casing_df = self._compute_bbox_gap_casing(casings_df)\n\n    return gap_casing_df</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine.GridRefine.extract_xz_corn_coords","title":"<code>extract_xz_corn_coords() -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>generate xcorn and zcorn coordinates</p> Source code in <code>src/WellClass/libs/grid_utils/grid_refine.py</code> <pre><code>def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\" generate xcorn and zcorn coordinates\n    \"\"\"\n\n    # for convenience\n    mesh_df = self.mesh_df\n\n    # for shifting\n    sDX = self.main_grd_dx/2\n    sDY = self.main_grd_dy/2\n\n    # generate grid coordinates for plotting\n    xcorn, zcorn = extract_xz_corn_coords(mesh_df, sDX, sDY)\n\n    return xcorn, zcorn</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine.GridRefine.extract_xz_slice","title":"<code>extract_xz_slice(prop='PERMX') -&gt; np.ndarray</code>","text":"<p>generate x-z PERM slice</p> <p>Parameters:</p> <ul> <li> <code>prop</code>               (<code>str</code>, default:                   <code>'PERMX'</code> )           \u2013            <p>the property name, default: PERMX</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: x-z slice of the property</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_refine.py</code> <pre><code>def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n    \"\"\" generate x-z PERM slice\n\n        Args:\n            prop (str): the property name, default: PERMX\n\n        Returns:\n            np.ndarray: x-z slice of the property\n    \"\"\"\n    # for convenience\n    mesh_df = self.mesh_df\n\n    # extract permeability\n    Z = extract_xz_prop_slice(mesh_df, prop=prop)\n\n    return Z </code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine_base","title":"<code>src.WellClass.libs.grid_utils.grid_refine_base</code>","text":""},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine_base.GridRefineBase","title":"<code>GridRefineBase</code>","text":"Source code in <code>src/WellClass/libs/grid_utils/grid_refine_base.py</code> <pre><code>class GridRefineBase:\n\n    def __init__(self, \n                 grid_coarse: GridCoarse,\n                 LGR_sizes_x: List[float], \n                 LGR_sizes_y: List[float], \n                 LGR_sizes_z: np.ndarray,\n                 min_grd_size: float):\n        \"\"\" dataframe for LGR mesh for the center coarse cell\n\n            Args:\n\n                grid_coarse (GridCoarse): information on coarse grid\n                LGR_sizes_x (list[float]): LGR x grid intervals\n                LGR_sizes_y (list[float]): LGR y grid intervals\n                LGR_sizes_z (np.ndarray): LGR DZ inernals\n                min_grd_size (float): minimize grid size\n        \"\"\"\n\n        self.min_grd_size = min_grd_size\n\n        # dx/dy of coarse grid\n        self.main_grd_dx = grid_coarse.main_grd_dx\n        self.main_grd_dy = grid_coarse.main_grd_dy\n\n        # LGR dimensions\n        nx = len(LGR_sizes_x)\n        ny = len(LGR_sizes_y)\n        nz = len(LGR_sizes_z)\n\n        print(f'LGR dimension: nx={nx}, ny={ny}, nz={nz}')\n\n        # set dimensions\n        self.nx, self.ny, self.nz = nx, ny, nz\n\n        #Create i, j, k indices\n        cell_ijk = np.indices((nx, ny, nz))\n        cell_ijk = cell_ijk.reshape((3, nx * ny * nz)).T\n\n        #Create LGR Dataframe with indices\n        mesh_df = pd.DataFrame(data = cell_ijk, columns = ['i', 'j', 'k'])\n\n        # TODO(hzh): why not in the order of ['k', 'j']?\n        mesh_df.sort_values(by=['k', 'i'], inplace = True)\n        mesh_df.reset_index(inplace=True, drop=True)\n\n        #\n        self.mesh_df = mesh_df\n\n        # set up fields\n        self._set_cell_intervals(self.mesh_df, \n                                 LGR_sizes_x, \n                                 LGR_sizes_y, \n                                 LGR_sizes_z)\n        self._set_cell_coords(self.mesh_df)\n        self._set_z_corners(self.mesh_df)       \n\n        # indices for center finer grid\n        mid_i = grid_coarse.main_grd_i\n        mid_j = grid_coarse.main_grd_j\n\n        self._upscale_properties(grid_coarse.grid_init, mid_i, mid_j)\n\n    def _set_cell_intervals(self, \n                            mesh_df: pd.DataFrame, \n                            LGR_sizes_x: List[float], \n                            LGR_sizes_y: List[float], \n                            LGR_sizes_z: np.ndarray):\n        \"\"\" Creat DX, DY, DZ for LGR mesh\n\n            Args:\n\n                mesh_df (pd.DataFrame): dataframe for LGR mesh of the center coarse cell\n                LGR_sizes_x (list[float]): LGR x grid intervals\n                LGR_sizes_y (list[float]): LGR y grid intervals\n                LGR_sizes_z (np.ndarray): LGR DZ grid inernals\n        \"\"\"\n\n        # mesh\n        DX_grid, DZ_grid, DY_grid = np.meshgrid(LGR_sizes_x, LGR_sizes_z, LGR_sizes_y)\n\n        # internals\n        mesh_df['DX'] = DX_grid.flatten()\n        mesh_df['DY'] = DY_grid.flatten()\n        mesh_df['DZ'] = DZ_grid.flatten()\n\n    def _set_cell_coords(self, mesh_df):\n        \"\"\" Create cell coordinate X, Y, Z for LGR mesh\n\n            Args:\n\n                mesh_df (pd.DataFrame): dataframe for LGR mesh of the center coarse cell\n        \"\"\"\n\n        # cell coordinates\n        xcoord = (mesh_df.query(\"j==0&amp;k==0\").DX.cumsum() - mesh_df.query(\"j==0&amp;k==0\").DX/2).values\n        ycoord = (mesh_df.query(\"i==0&amp;k==0\").DY.cumsum() - mesh_df.query(\"i==0&amp;k==0\").DY/2).values\n        zcoord = (mesh_df.query(\"i==0&amp;j==0\").DZ.cumsum() - mesh_df.query(\"i==0&amp;j==0\").DZ/2).values\n\n        # TODO(hzh): a bug?\n        # map_X = dict(zip(mesh_df.query(\"j==0&amp;j==0\")['i'], xcoord))\n        map_X = dict(zip(mesh_df.query(\"j==0&amp;k==0\")['i'], xcoord))\n        map_Y = dict(zip(mesh_df.query(\"i==0&amp;k==0\")['j'], ycoord))\n        map_Z = dict(zip(mesh_df.query(\"i==0&amp;j==0\")['k'], zcoord))\n\n        # save cell coordinates X, Y, Z to dataframe\n        mesh_df['X'] = mesh_df['i'].map(map_X)\n        mesh_df['Y'] = mesh_df['j'].map(map_Y)\n        mesh_df['Z'] = mesh_df['k'].map(map_Z)\n\n    def _set_z_corners(self, mesh_df):\n        \"\"\" save Corner Z points to dataframe\n\n            Args:\n\n                mesh_df (pd.DataFrame): dataframe for LGR mesh of the center coarse cell\n        \"\"\"\n\n        mesh_df['Zcorn_top'] = mesh_df['Z'] - mesh_df['DZ']/2\n        mesh_df['Zcorn_bottom'] = mesh_df['Z'] + mesh_df['DZ']/2\n\n    def _upscale_properties(self, \n                            grid_coarse: GridCoarse, \n                            mid_i: int, \n                            mid_j: int):\n        \"\"\" Upscale coarse properties to LGR mesh\n\n            Args:\n                grid_coarse (GridCoarse): information on coarse grid\n                mid_i (int): x index of center cell on the coarse grid\n                mid_j (int): y index of center cell on the coarse grid\n        \"\"\"\n\n        # for convenience only\n        mesh_df = self.mesh_df\n\n        # properties\n        fields = ['PORV', \n                  'PERMX', 'PERMY', 'PERMZ', \n                  'MULTX', 'MULTY', 'MULTZ', \n                  'MULTX-', 'MULTY-', 'MULTZ-', \n                  'PORO']\n\n        # Upscale coarse properties to LGR grids\n\n        for field in fields:\n            # mesh_df[field] = np.nan\n            mesh_df[field] = 0.0                    # TODO(hzh): what should I put here?\n\n        for idx, row in grid_coarse.query('i==@mid_i &amp; j==@mid_j').iterrows():\n\n            # switch to corner coords, coarse grid\n            top  = row.Z - row.DZ/2\n            base = row.Z + row.DZ/2\n\n            for field in fields:\n\n                mesh_df.loc[(mesh_df['Z']&gt;=top) &amp; (mesh_df['Z']&lt;base), field] = row[field]\n\n    def _set_material_type(self, \n                            drilling_df: pd.DataFrame, \n                            casings_df: pd.DataFrame, \n                            barriers_mod_df: pd.DataFrame) -&gt; None:\n        \"\"\" Assign material types, such as openholes, overburden, cement bond, etc.\n\n            Args:\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier    \n        \"\"\"\n\n        # only for convenience\n        mesh_df = self.mesh_df\n\n        # set default material to 'overburden'\n        mesh_df['material'] = 'overburden'\n\n        # ### 1. Drilling\n        for idx, row in drilling_df.iterrows():\n\n            top, bottom = row['top_msl'], row['bottom_msl']  # noqa: F841\n\n            if top &lt; mesh_df['Zcorn_bottom'].max():\n\n                # extract bounding box\n                k_min, k_max = row['k_min'], row['k_max']\n                ij_min, ij_max = row['ij_min'], row['ij_max']\n\n                # 1.1 set material type to openhole\n                criteria =  '(k &gt;= @k_min)  &amp; (k &lt;= @k_max) &amp; \\\n                             (i &gt;= @ij_min) &amp; (i &lt;= @ij_max) &amp; \\\n                             (j &gt;= @ij_min) &amp; (j &lt;= @ij_max)'\n                mesh_df.loc[mesh_df.eval(criteria), 'material'] = 'openhole'\n\n        # ### 2. Casings\n        for ic, (idx, row) in enumerate(casings_df.iterrows()):\n\n            # extract bounding box\n            k_min, k_max = row['k_min'], row['k_max']  # noqa: F841\n            ij_min, ij_max = row['ij_min'], row['ij_max']  # noqa: F841\n            toc_k_min, toc_k_max = row['toc_k_min'], row['toc_k_max']  # noqa: F841\n\n            # 2.1 set material type to annulus\n            # x\n            criteria_i =  '(material == \"openhole\") &amp; \\\n                           (k &gt;= @k_min) &amp; (k &lt;= @k_max) &amp; \\\n                            ((i &lt; @ij_min) | (i &gt; @ij_max))'\n            mesh_df.loc[mesh_df.eval(criteria_i), 'material'] = 'annulus'\n            # y\n            criteria_j =  '(material == \"openhole\") &amp; \\\n                           (k &gt;= @k_min) &amp; (k &lt;= @k_max) &amp; \\\n                           ((j &lt; @ij_min) | (j &gt; @ij_max))'\n            mesh_df.loc[mesh_df.eval(criteria_j), 'material'] = 'annulus'\n\n            # 2.2 set material type to cement_bond\n            criteria = '(material == \"annulus\") &amp; \\\n                        (k &gt;= @toc_k_min) &amp; (k &lt;= @toc_k_max)' \n            mesh_df.loc[mesh_df.eval(criteria), 'material'] = f'cement_bond_{ic}'\n\n            # 2.3 set material type to openhole\n            criteria = '(material == \"annulus\")'  \n            mesh_df.loc[mesh_df.eval(criteria), 'material'] = 'openhole'\n            # mesh_df.loc[mesh_df.eval(criteria_j), 'material'] = 'cementbond'   \n\n        # ### 3. Barriers\n        for ib, (idx, row) in enumerate(barriers_mod_df.iterrows()):\n\n            b_k_min, b_k_max = row['k_min'], row['k_max']  # noqa: F841\n\n            criteria = '(material == \"openhole\") &amp; \\\n                        (k &gt;= @b_k_min) &amp; (k &lt;= @b_k_max)' \n            mesh_df.loc[mesh_df.eval(criteria), 'material'] = f'barrier_{ib}'\n\n\n    def _set_permeability(self, \n                            drilling_df: pd.DataFrame, \n                            casings_df: pd.DataFrame, \n                            barriers_mod_df: pd.DataFrame) -&gt; None:\n        \"\"\" Actual function to assign permeability according to material type\n\n            Args:\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier    \n        \"\"\"\n\n        # for convenience only\n        mesh_df = self.mesh_df\n\n        # set permeability according to material type\n\n        # 1. openhole\n        oh_perm = drilling_df['oh_perm'].iloc[0]\n        criteria = 'material == \"openhole\"'\n        mesh_df.loc[mesh_df.eval(criteria), 'PERMX'] = oh_perm\n\n        # 2. cement bond\n        for ic, (_, row) in enumerate(casings_df.iterrows()):\n            cb_perm = row['cb_perm']\n            criteria = f'material == \"cement_bond_{ic}\"'\n            mesh_df.loc[mesh_df.eval(criteria), 'PERMX'] = cb_perm\n\n        # 3. barrier\n        for ib, (_, row) in enumerate(barriers_mod_df.iterrows()):\n            barrier_perm = row['barrier_perm']\n            criteria = f'material == \"barrier_{ib}\"'\n            mesh_df.loc[mesh_df.eval(criteria), 'PERMX'] = barrier_perm\n\n    def _compute_num_lateral_fine_grd(self, \n                                        drilling_df: pd.DataFrame, \n                                        casings_df: pd.DataFrame, \n                                        barriers_mod_df: pd.DataFrame):\n        \"\"\" compute number of fine grid in x-y directions\n\n            Args:\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier            \n        \"\"\"\n        # for convenience\n        min_grd_size = self.min_grd_size\n\n        # n_grd_id for well elements\n        drilling_df['n_grd_id']  = drilling_df['diameter_m'].map(lambda x: compute_ngrd(x, min_grd_size))\n        casings_df[ 'n_grd_id']  = casings_df['diameter_m'].map(lambda x: compute_ngrd(x, min_grd_size))\n        barriers_mod_df['n_grd_id'] = barriers_mod_df['diameter_m'].map(lambda x: compute_ngrd(x, min_grd_size))\n\n        # borehole_df['n_grd_id'] = borehole_df['id_m'].map(lambda x: compute_ngrd(x, min_grd_size))\n\n    def _compute_bbox(self, \n                        drilling_df: pd.DataFrame, \n                        casings_df: pd.DataFrame, \n                        barriers_mod_df: pd.DataFrame) -&gt; None:\n        \"\"\" Compute bounding boxes for drillings, casings and barriers.\n\n            Args:\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier       \n        \"\"\"\n\n        # for convenience\n        mesh_df = self.mesh_df\n        nxy = self.nx\n\n        # depth cut off\n        maxDepth = mesh_df['Zcorn_bottom'].max()\n\n        # ### 1. Drillings\n        compute_bbox(mesh_df, drilling_df, nxy=nxy, maxDepth=maxDepth)\n\n        # ### 2. Casings\n        compute_bbox(mesh_df, casings_df, nxy=nxy, maxDepth=maxDepth, is_casing=True)\n\n        # ### 3. Barriers\n        compute_bbox(mesh_df, barriers_mod_df, nxy=nxy, maxDepth=maxDepth)\n\n    def _compute_bbox_gap_casing(self, \n                                 casings_df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\" compute bbox of casing for GaP \n\n            Args:\n                casings_df (pd.DataFrame): information about casings and cement-bond\n\n            Returns:\n                an updated dataframe specifically for GaP code\n        \"\"\"\n\n        # for convenience\n        mesh_df = self.mesh_df\n        nxy = self.nx\n        min_grd_size = self.min_grd_size\n\n        # generate new pd.DataFrame by trimming casings\n        # gap_casing_df = trim_casings_cement(casings_df)\n        gap_casing_df = casings_df\n\n        # compute number of lateral grid (refined)\n        gap_casing_df[ 'n_grd_id']  = casings_df['diameter_m'].map(lambda x: compute_ngrd(x, min_grd_size))\n\n        # Casings\n        compute_bbox(mesh_df, gap_casing_df, nxy=nxy, is_casing=True)\n\n        return gap_casing_df</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_refine_base.GridRefineBase.__init__","title":"<code>__init__(grid_coarse: GridCoarse, LGR_sizes_x: List[float], LGR_sizes_y: List[float], LGR_sizes_z: np.ndarray, min_grd_size: float)</code>","text":"<p>dataframe for LGR mesh for the center coarse cell</p> <p>Args:</p> <pre><code>grid_coarse (GridCoarse): information on coarse grid\nLGR_sizes_x (list[float]): LGR x grid intervals\nLGR_sizes_y (list[float]): LGR y grid intervals\nLGR_sizes_z (np.ndarray): LGR DZ inernals\nmin_grd_size (float): minimize grid size</code></pre> Source code in <code>src/WellClass/libs/grid_utils/grid_refine_base.py</code> <pre><code>def __init__(self, \n             grid_coarse: GridCoarse,\n             LGR_sizes_x: List[float], \n             LGR_sizes_y: List[float], \n             LGR_sizes_z: np.ndarray,\n             min_grd_size: float):\n    \"\"\" dataframe for LGR mesh for the center coarse cell\n\n        Args:\n\n            grid_coarse (GridCoarse): information on coarse grid\n            LGR_sizes_x (list[float]): LGR x grid intervals\n            LGR_sizes_y (list[float]): LGR y grid intervals\n            LGR_sizes_z (np.ndarray): LGR DZ inernals\n            min_grd_size (float): minimize grid size\n    \"\"\"\n\n    self.min_grd_size = min_grd_size\n\n    # dx/dy of coarse grid\n    self.main_grd_dx = grid_coarse.main_grd_dx\n    self.main_grd_dy = grid_coarse.main_grd_dy\n\n    # LGR dimensions\n    nx = len(LGR_sizes_x)\n    ny = len(LGR_sizes_y)\n    nz = len(LGR_sizes_z)\n\n    print(f'LGR dimension: nx={nx}, ny={ny}, nz={nz}')\n\n    # set dimensions\n    self.nx, self.ny, self.nz = nx, ny, nz\n\n    #Create i, j, k indices\n    cell_ijk = np.indices((nx, ny, nz))\n    cell_ijk = cell_ijk.reshape((3, nx * ny * nz)).T\n\n    #Create LGR Dataframe with indices\n    mesh_df = pd.DataFrame(data = cell_ijk, columns = ['i', 'j', 'k'])\n\n    # TODO(hzh): why not in the order of ['k', 'j']?\n    mesh_df.sort_values(by=['k', 'i'], inplace = True)\n    mesh_df.reset_index(inplace=True, drop=True)\n\n    #\n    self.mesh_df = mesh_df\n\n    # set up fields\n    self._set_cell_intervals(self.mesh_df, \n                             LGR_sizes_x, \n                             LGR_sizes_y, \n                             LGR_sizes_z)\n    self._set_cell_coords(self.mesh_df)\n    self._set_z_corners(self.mesh_df)       \n\n    # indices for center finer grid\n    mid_i = grid_coarse.main_grd_i\n    mid_j = grid_coarse.main_grd_j\n\n    self._upscale_properties(grid_coarse.grid_init, mid_i, mid_j)</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_lgr","title":"<code>src.WellClass.libs.grid_utils.grid_lgr</code>","text":""},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_lgr.GridLGR","title":"<code>GridLGR</code>","text":"Source code in <code>src/WellClass/libs/grid_utils/grid_lgr.py</code> <pre><code>class GridLGR:\n\n    def __init__(self, sim_case: Union[str, pathlib.Path]) -&gt; None:\n        \"\"\" This is used to process .EGRID file\n\n            Args:\n                sim_case (str): name prefix for eclipse/pflotran case\n        \"\"\"\n\n        # convert it to string, in case it is pathlib.Path\n        sim_case = str(sim_case)\n\n        #Get grid dimensions and coordinates\n        grid = EclGrid(sim_case + \".EGRID\") \n        #init = EclGrid(simcase + \".INIT\") \n        init = EclInitFile(grid, sim_case + \".INIT\")\n\n        # the coarse grid dimensions\n        self.NX, self.NY, self.NZ, _ = grid.get_dims()\n\n        #Process init file\n        lgr_name = grid.get_lgr(0).get_name()\n        lgr_grid = grid.get_lgr(lgr_name)\n\n        # # Store INIT parameters into a Pandas Dataframe\n\n        lgr_index = lgr_grid.export_index()\n\n        # Static properties Dataframe\n        for key in init.keys():\n            try:\n                lgr_index[key] = init[key][1].numpy_view()\n            except Exception:\n                continue\n\n        # \n        self.lgr_index = lgr_index\n\n        # compute middle index for extraction of DX and DY\n        mid_i = lgr_index.i.max()//2  # noqa: F841\n        mid_j = lgr_index.j.max()//2  # noqa: F841\n\n        # compute DX and DY on the coarse grid by summing LGR grid\n        self.main_grd_dx = lgr_index.query(\"j==@mid_j&amp;k==0\").DX.sum()\n        self.main_grd_dy = lgr_index.query(\"i==@mid_i&amp;k==0\").DY.sum()\n\n    def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\" generate xcorn and zcorn coordinates\n        \"\"\"\n\n        # for convenience\n        lgr_index = self.lgr_index\n\n        # shifting half coarse grid\n        sDX = self.main_grd_dx/2\n        sDY = self.main_grd_dy/2\n\n        # generate corner grid coordinates for plotting\n        xcorn, zcorn = extract_xz_corn_coords(lgr_index, sDX, sDY)\n\n        return xcorn, zcorn \n\n    def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n        \"\"\" generate x-z PERM slice\n\n            Args:\n                prop (str): the property name, default: PERMX\n\n            Returns:\n                np.ndarray: x-z slice of the property\n        \"\"\"\n        # for convenience\n        lgr_index = self.lgr_index\n\n        # extract permeability\n        Z = extract_xz_prop_slice(lgr_index, prop=prop)\n\n        return Z </code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_lgr.GridLGR.__init__","title":"<code>__init__(sim_case: Union[str, pathlib.Path]) -&gt; None</code>","text":"<p>This is used to process .EGRID file</p> <p>Parameters:</p> <ul> <li> <code>sim_case</code>               (<code>str</code>)           \u2013            <p>name prefix for eclipse/pflotran case</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_lgr.py</code> <pre><code>def __init__(self, sim_case: Union[str, pathlib.Path]) -&gt; None:\n    \"\"\" This is used to process .EGRID file\n\n        Args:\n            sim_case (str): name prefix for eclipse/pflotran case\n    \"\"\"\n\n    # convert it to string, in case it is pathlib.Path\n    sim_case = str(sim_case)\n\n    #Get grid dimensions and coordinates\n    grid = EclGrid(sim_case + \".EGRID\") \n    #init = EclGrid(simcase + \".INIT\") \n    init = EclInitFile(grid, sim_case + \".INIT\")\n\n    # the coarse grid dimensions\n    self.NX, self.NY, self.NZ, _ = grid.get_dims()\n\n    #Process init file\n    lgr_name = grid.get_lgr(0).get_name()\n    lgr_grid = grid.get_lgr(lgr_name)\n\n    # # Store INIT parameters into a Pandas Dataframe\n\n    lgr_index = lgr_grid.export_index()\n\n    # Static properties Dataframe\n    for key in init.keys():\n        try:\n            lgr_index[key] = init[key][1].numpy_view()\n        except Exception:\n            continue\n\n    # \n    self.lgr_index = lgr_index\n\n    # compute middle index for extraction of DX and DY\n    mid_i = lgr_index.i.max()//2  # noqa: F841\n    mid_j = lgr_index.j.max()//2  # noqa: F841\n\n    # compute DX and DY on the coarse grid by summing LGR grid\n    self.main_grd_dx = lgr_index.query(\"j==@mid_j&amp;k==0\").DX.sum()\n    self.main_grd_dy = lgr_index.query(\"i==@mid_i&amp;k==0\").DY.sum()</code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_lgr.GridLGR.extract_xz_corn_coords","title":"<code>extract_xz_corn_coords() -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>generate xcorn and zcorn coordinates</p> Source code in <code>src/WellClass/libs/grid_utils/grid_lgr.py</code> <pre><code>def extract_xz_corn_coords(self) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\" generate xcorn and zcorn coordinates\n    \"\"\"\n\n    # for convenience\n    lgr_index = self.lgr_index\n\n    # shifting half coarse grid\n    sDX = self.main_grd_dx/2\n    sDY = self.main_grd_dy/2\n\n    # generate corner grid coordinates for plotting\n    xcorn, zcorn = extract_xz_corn_coords(lgr_index, sDX, sDY)\n\n    return xcorn, zcorn </code></pre>"},{"location":"code_references/well_class/grids/#src.WellClass.libs.grid_utils.grid_lgr.GridLGR.extract_xz_slice","title":"<code>extract_xz_slice(prop='PERMX') -&gt; np.ndarray</code>","text":"<p>generate x-z PERM slice</p> <p>Parameters:</p> <ul> <li> <code>prop</code>               (<code>str</code>, default:                   <code>'PERMX'</code> )           \u2013            <p>the property name, default: PERMX</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>np.ndarray: x-z slice of the property</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/grid_lgr.py</code> <pre><code>def extract_xz_slice(self, prop='PERMX') -&gt; np.ndarray:\n    \"\"\" generate x-z PERM slice\n\n        Args:\n            prop (str): the property name, default: PERMX\n\n        Returns:\n            np.ndarray: x-z slice of the property\n    \"\"\"\n    # for convenience\n    lgr_index = self.lgr_index\n\n    # extract permeability\n    Z = extract_xz_prop_slice(lgr_index, prop=prop)\n\n    return Z </code></pre>"},{"location":"code_references/well_class/lgr_builder/","title":"LGR builder","text":""},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder","title":"<code>src.WellClass.libs.grid_utils.LGR_builder</code>","text":""},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder.LGRBuilder","title":"<code>LGRBuilder</code>","text":"<p>               Bases: <code>LGRBuilderBase</code></p> Source code in <code>src/WellClass/libs/grid_utils/LGR_builder.py</code> <pre><code>class LGRBuilder (LGRBuilderBase):\n\n    def __init__(self,\n                 simcase: str, \n                 annulus_df: pd.DataFrame,\n                 drilling_df: pd.DataFrame, \n                 Ali_way: bool):\n        \"\"\" Builder for generating LGR grid\n\n            Args:\n                simcase (str): simulation case, information about coarse grid\n                annulus_df (pd.DataFrame): information about annulus\n                drilling_df (pd.DataFrame): information about drilling\n                Ali_way (bool): use Ali's algorithm to compute lateral grids and apply refdepth in z direction\n        \"\"\"\n\n        ##### 1. grid_coarse \n        # Loading the model\n        self.grid_coarse = GridCoarse(str(simcase))\n\n        ##### 2. LGR grid sizes\n        # LGR grid information in x, y, z directions\n        self.lgr_info = LGRGridInfo(self.grid_coarse,\n                                    annulus_df,\n                                    drilling_df,\n                                    Ali_way)\n\n        ##### 3. LGR refined grid\n        # Set up dataframe for LGR mesh\n        self.grid_refine = GridRefine(self.grid_coarse,\n                                      self.lgr_info.LGR_sizes_x, \n                                      self.lgr_info.LGR_sizes_y, \n                                      self.lgr_info.LGR_sizes_z,\n                                      self.lgr_info.min_grd_size)\n\n    def build_grdecl(self, \n                     output_folder: str, \n                     LGR_NAME: str,\n                     drilling_df: pd.DataFrame, \n                     casings_df: pd.DataFrame, \n                     barriers_mod_df: pd.DataFrame) -&gt; pd.DataFrame:\n        \"\"\" build .grdecl file and output it\n\n            Args:\n\n                output_folder (str): output folder\n                LGR_NAME (str): output file name\n                drilling_df (pd.DataFrame): information about drilling\n                casings_df (pd.DataFrame): information about casings and cement-bond\n                barriers_mod_df (pd.DataFrame): information about barrier                 \n        \"\"\"\n\n        ##### 4. build LGR\n        gap_casing_df = self.grid_refine.build_LGR(drilling_df, \n                                                   casings_df, \n                                                   barriers_mod_df)\n\n        ##### 5. output LGR\n        self._build_grdecl(output_folder, \n                            LGR_NAME,\n                            drilling_df,\n                            gap_casing_df,    # casings_df,\n                            barriers_mod_df,\n                            self.grid_coarse.NX, self.grid_coarse.NY,\n                            self.grid_coarse.main_grd_i, self.grid_coarse.main_grd_j,\n                            self.grid_coarse.main_grd_min_k, self.grid_coarse.main_grd_max_k,\n                            self.grid_coarse.no_of_layers_in_OB,\n                            self.lgr_info.LGR_sizes_x, \n                            self.lgr_info.LGR_numb_z,\n                            self.lgr_info.min_grd_size)\n\n        return gap_casing_df</code></pre>"},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder.LGRBuilder.__init__","title":"<code>__init__(simcase: str, annulus_df: pd.DataFrame, drilling_df: pd.DataFrame, Ali_way: bool)</code>","text":"<p>Builder for generating LGR grid</p> <p>Parameters:</p> <ul> <li> <code>simcase</code>               (<code>str</code>)           \u2013            <p>simulation case, information about coarse grid</p> </li> <li> <code>annulus_df</code>               (<code>DataFrame</code>)           \u2013            <p>information about annulus</p> </li> <li> <code>drilling_df</code>               (<code>DataFrame</code>)           \u2013            <p>information about drilling</p> </li> <li> <code>Ali_way</code>               (<code>bool</code>)           \u2013            <p>use Ali's algorithm to compute lateral grids and apply refdepth in z direction</p> </li> </ul> Source code in <code>src/WellClass/libs/grid_utils/LGR_builder.py</code> <pre><code>def __init__(self,\n             simcase: str, \n             annulus_df: pd.DataFrame,\n             drilling_df: pd.DataFrame, \n             Ali_way: bool):\n    \"\"\" Builder for generating LGR grid\n\n        Args:\n            simcase (str): simulation case, information about coarse grid\n            annulus_df (pd.DataFrame): information about annulus\n            drilling_df (pd.DataFrame): information about drilling\n            Ali_way (bool): use Ali's algorithm to compute lateral grids and apply refdepth in z direction\n    \"\"\"\n\n    ##### 1. grid_coarse \n    # Loading the model\n    self.grid_coarse = GridCoarse(str(simcase))\n\n    ##### 2. LGR grid sizes\n    # LGR grid information in x, y, z directions\n    self.lgr_info = LGRGridInfo(self.grid_coarse,\n                                annulus_df,\n                                drilling_df,\n                                Ali_way)\n\n    ##### 3. LGR refined grid\n    # Set up dataframe for LGR mesh\n    self.grid_refine = GridRefine(self.grid_coarse,\n                                  self.lgr_info.LGR_sizes_x, \n                                  self.lgr_info.LGR_sizes_y, \n                                  self.lgr_info.LGR_sizes_z,\n                                  self.lgr_info.min_grd_size)</code></pre>"},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder.LGRBuilder.build_grdecl","title":"<code>build_grdecl(output_folder: str, LGR_NAME: str, drilling_df: pd.DataFrame, casings_df: pd.DataFrame, barriers_mod_df: pd.DataFrame) -&gt; pd.DataFrame</code>","text":"<p>build .grdecl file and output it</p> <p>Args:</p> <pre><code>output_folder (str): output folder\nLGR_NAME (str): output file name\ndrilling_df (pd.DataFrame): information about drilling\ncasings_df (pd.DataFrame): information about casings and cement-bond\nbarriers_mod_df (pd.DataFrame): information about barrier</code></pre> Source code in <code>src/WellClass/libs/grid_utils/LGR_builder.py</code> <pre><code>def build_grdecl(self, \n                 output_folder: str, \n                 LGR_NAME: str,\n                 drilling_df: pd.DataFrame, \n                 casings_df: pd.DataFrame, \n                 barriers_mod_df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\" build .grdecl file and output it\n\n        Args:\n\n            output_folder (str): output folder\n            LGR_NAME (str): output file name\n            drilling_df (pd.DataFrame): information about drilling\n            casings_df (pd.DataFrame): information about casings and cement-bond\n            barriers_mod_df (pd.DataFrame): information about barrier                 \n    \"\"\"\n\n    ##### 4. build LGR\n    gap_casing_df = self.grid_refine.build_LGR(drilling_df, \n                                               casings_df, \n                                               barriers_mod_df)\n\n    ##### 5. output LGR\n    self._build_grdecl(output_folder, \n                        LGR_NAME,\n                        drilling_df,\n                        gap_casing_df,    # casings_df,\n                        barriers_mod_df,\n                        self.grid_coarse.NX, self.grid_coarse.NY,\n                        self.grid_coarse.main_grd_i, self.grid_coarse.main_grd_j,\n                        self.grid_coarse.main_grd_min_k, self.grid_coarse.main_grd_max_k,\n                        self.grid_coarse.no_of_layers_in_OB,\n                        self.lgr_info.LGR_sizes_x, \n                        self.lgr_info.LGR_numb_z,\n                        self.lgr_info.min_grd_size)\n\n    return gap_casing_df</code></pre>"},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder_base","title":"<code>src.WellClass.libs.grid_utils.LGR_builder_base</code>","text":""},{"location":"code_references/well_class/lgr_builder/#src.WellClass.libs.grid_utils.LGR_builder_base.LGRBuilderBase","title":"<code>LGRBuilderBase</code>","text":"Source code in <code>src/WellClass/libs/grid_utils/LGR_builder_base.py</code> <pre><code>class LGRBuilderBase:\n\n    def _build_grdecl(self, \n                      output_folder: str, \n                      LGR_NAME: str,\n                      drilling_df: pd.DataFrame, \n                      casings_df: pd.DataFrame, \n                      barriers_mod_df: pd.DataFrame,\n                      NX: int, NY: int,\n                      main_grd_i: int, main_grd_j: int,\n                      main_grd_min_k: int, main_grd_max_k: int,\n                      no_of_layers_in_OB: int,\n                      LGR_sizes_x,\n                      LGR_numb_z,\n                      min_grd_size: float):\n        \"\"\" build grdecl file and output it\n        \"\"\"\n        # 0. prepare file for output\n\n        # check output directory\n        if not os.path.exists(output_folder):\n            os.makedirs(output_folder, exist_ok=True)\n\n        # generate output file name\n        out_fname = os.path.join(output_folder, LGR_NAME+'.grdecl')\n\n        # open it\n        if os.path.exists(out_fname):\n            O = open(out_fname,\"r+\")  # noqa: E741\n        else: \n            O = open(out_fname,\"x\")  # noqa: E741\n\n        O.truncate(0)\n\n        # 1. start the process\n        pre_CARFIN(LGR_NAME,\n                    NX, NY,\n                    main_grd_i+1, main_grd_j+1, \n                    no_of_layers_in_OB, \n                    O)\n\n        # 2. keywods\n        CARFIN_keywords(LGR_NAME,\n                        main_grd_i+1, main_grd_j+1, \n                        main_grd_min_k+1, main_grd_max_k+1, \n                        LGR_sizes_x, \n                        LGR_numb_z, \n                        min_grd_size,\n                        O)\n\n        # 3. the pipes/openholes/barriers\n        df_to_gap_casing(drilling_df, \n                         casings_df,\n                         LGR_NAME,\n                         O)\n\n        df_to_gap_barrier(barriers_mod_df,\n                          LGR_NAME,\n                          O)\n\n        # 4. handle reopen hole\n        nz_ovb = 10 * no_of_layers_in_OB   # total number of ovb layers (refined grid)\n\n        # bbox\n        reopen_ID, x_min_reopen, x_max_reopen = \\\n        compute_bbox_for_reopen(drilling_df, \n                                casings_df,\n                                nz_ovb)\n\n        endCARFIN2(LGR_NAME,\n                    reopen_ID, \n                    x_min_reopen+1,    # fortran indexing\n                    x_max_reopen+1,    # fortran indexing\n                    nz_ovb,\n                    LGR_sizes_x, \n                    O)\n\n        # 2. done\n        O.close()\n\n        # for qc\n        print ('Output LGR CARFIN to: ', os.path.abspath(out_fname))</code></pre>"},{"location":"code_references/well_class/models/","title":"Models","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils","title":"<code>src.WellClass.libs.models.well_model_utils</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.WellHeaderModel","title":"<code>WellHeaderModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>General information about the well.</p> <p>Parameters:</p> <ul> <li> <code>well_name</code>               (<code>str</code>)           \u2013            <p>well name</p> </li> <li> <code>well_rkb</code>               (<code>float</code>)           \u2013            <p>RKB elevation</p> </li> <li> <code>sf_depth_msl</code>               (<code>float</code>)           \u2013            <p>depth of the sea floor</p> </li> <li> <code>well_td_rkb</code>               (<code>float</code>)           \u2013            <p>total depth of RKB</p> </li> <li> <code>sf_temp</code>               (<code>float</code>)           \u2013            <p>sea floor temperature</p> </li> <li> <code>geo_tgrad</code>               (<code> (float</code>)           \u2013            <p>geothermal gradient</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class WellHeaderModel(BaseModel):\n    \"\"\" General information about the well.\n\n        Args:\n            well_name (str): well name\n            well_rkb (float): RKB elevation\n            sf_depth_msl (float): depth of the sea floor\n            well_td_rkb (float): total depth of RKB\n            sf_temp (float): sea floor temperature\n            geo_tgrad  (float): geothermal gradient\n    \"\"\"\n    well_name: str\n    well_rkb: Union[int, float]\n    sf_depth_msl: Union[int, float]\n    well_td_rkb: Union[int, float]\n    sf_temp: Union[int, float]\n    geo_tgrad: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingRawModel","title":"<code>DrillingRawModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB </p> </li> <li> <code>diameter_in</code>               (<code>(float, str)</code>)           \u2013            <p>the diameter of the borehole in inches</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingRawModel(BaseModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB \n            diameter_in (float, str): the diameter of the borehole in inches\n    \"\"\"\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    diameter_in: Union[float, int, str]\n\n    @field_validator('diameter_in')\n    def diameter_in_converter(cls, v):\n        if isinstance(v, (float, int)):\n            return v\n        elif isinstance(v, str):\n            return fraction_float(v)\n        else:\n            raise ValueError('diameter_in must be a float or string')</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.DrillingModel","title":"<code>DrillingModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the drilling intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>oh_perm</code>               (<code>float</code>)           \u2013            <p>faked permeability for open-hole</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class DrillingModel(DrillingRawModel):\n    \"\"\" Information about the drilling intervals of the well\n\n        Args:\n            oh_perm (float): faked permeability for open-hole \n    \"\"\"\n    oh_perm: Union[int, float] = 10000</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CasingCementModel","title":"<code>CasingCementModel</code>","text":"<p>               Bases: <code>DrillingRawModel</code></p> <p>Information about the casing and cementing intervals of the well</p> <p>Parameters:</p> <ul> <li> <code>toc_rkb</code>               (<code>float</code>)           \u2013            <p>top of cement-bond in RKB  </p> </li> <li> <code>boc_rkb</code>               (<code>float</code>)           \u2013            <p>bottom of cement-bond in RKB </p> </li> <li> <code>shoe</code>               (<code>bool</code>)           \u2013            <p>whether or not it has a shoe</p> </li> <li> <code>cb_perm</code>               (<code>float</code>)           \u2013            <p>permeability for cement-bond</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CasingCementModel(DrillingRawModel):\n    \"\"\" Information about the casing and cementing intervals of the well\n\n        Args:\n          toc_rkb (float): top of cement-bond in RKB  \n          boc_rkb (float): bottom of cement-bond in RKB \n          shoe (bool): whether or not it has a shoe\n          cb_perm (float): permeability for cement-bond\n    \"\"\"\n    toc_rkb: Union[int, float]\n    boc_rkb: Union[int, float]\n    shoe: bool\n    cb_perm: Union[int, float] = 5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierModel","title":"<code>BarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Information about the barrier in the well </p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>the barrier name </p> </li> <li> <code>barrier_type</code>               (<code>str</code>)           \u2013            <p>the barrier type </p> </li> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>the top depth in RKB</p> </li> <li> <code>bottom_rkb</code>               (<code>float</code>)           \u2013            <p>the bottom depth in RKB</p> </li> <li> <code>barrier_perm</code>               (<code>float</code>)           \u2013            <p>permeability for the barrier</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierModel(BaseModel):\n    \"\"\" Information about the barrier in the well \n\n        Args:\n            barrier_name (str): the barrier name \n            barrier_type (str): the barrier type \n            top_rkb (float): the top depth in RKB\n            bottom_rkb (float): the bottom depth in RKB\n            barrier_perm (float): permeability for the barrier\n    \"\"\"\n    barrier_name: str\n    barrier_type: str\n    top_rkb: Union[int, float]\n    bottom_rkb: Union[int, float]\n    barrier_perm: Union[int, float] = 0.5</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.GeologyModel","title":"<code>GeologyModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>The geological units encountered in the well</p> <p>Parameters:</p> <ul> <li> <code>top_rkb</code>               (<code>float</code>)           \u2013            <p>top depth in RKB</p> </li> <li> <code>geol_unit</code>               (<code>str</code>)           \u2013            <p>name </p> </li> <li> <code>reservoir_flag</code>               (<code>bool</code>)           \u2013            <p>whether or not it is considered a reservoir</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class GeologyModel(BaseModel):\n    \"\"\" The geological units encountered in the well\n\n        Args:\n            top_rkb (float): top depth in RKB\n            geol_unit (str): name \n            reservoir_flag (bool): whether or not it is considered a reservoir  \n    \"\"\"\n    top_rkb: Union[int, float]\n    geol_unit: str\n    reservoir_flag: bool</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.AssumptionsModel","title":"<code>AssumptionsModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for assumptions</p> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class AssumptionsModel(BaseModel):\n    \"\"\" model for assumptions\n    \"\"\"\n    pass</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.ReservoirPressureModel","title":"<code>ReservoirPressureModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for reservoir pressure</p> <p>Parameters:</p> <ul> <li> <code>depth_msl</code>               (<code>float</code>)           \u2013            <p>mean sea level depth</p> </li> <li> <code>RP1</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP2</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> <li> <code>RP3</code>               (<code>str</code>)           \u2013            <p>reservoir pressure</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class ReservoirPressureModel(BaseModel):\n    \"\"\" Model for reservoir pressure\n\n        Args:\n            depth_msl (float): mean sea level depth\n            RP1 (str): reservoir pressure\n            RP2 (str): reservoir pressure\n            RP3 (str): reservoir pressure\n    \"\"\"\n    depth_msl: Union[int, float]\n    RP1: Union[str, float, int, None] = None\n    RP2: Union[str, float, int, None] = None\n    RP3: Union[str, float, int, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.CO2DatumModel","title":"<code>CO2DatumModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model for CO2 datum. Note it is not used.</p> <p>Parameters:</p> <ul> <li> <code>co2_msl</code>               (<code>float</code>)           \u2013            <p>CO2 datum depth</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class CO2DatumModel(BaseModel):\n    \"\"\" Model for CO2 datum. Note it is not used.\n\n        Args:\n            co2_msl (float): CO2 datum depth\n    \"\"\"\n    co2_msl: Union[int, float]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.MainBarrierModel","title":"<code>MainBarrierModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for main barrier</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name for proxy compute</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class MainBarrierModel(BaseModel):\n    \"\"\" model for main barrier\n\n        Args:\n            barrier_name (str): barrier name for proxy compute\n    \"\"\"\n    barrier_name: str</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model_utils.BarrierPermeabilityModel","title":"<code>BarrierPermeabilityModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model for Barrier permeability</p> <p>Parameters:</p> <ul> <li> <code>quality</code>               (<code>str</code>)           \u2013            <p>list of quality level</p> </li> <li> <code>kv</code>               (<code>float</code>)           \u2013            <p>list of permeability values</p> </li> </ul> Source code in <code>src/WellClass/libs/models/well_model_utils.py</code> <pre><code>class BarrierPermeabilityModel(BaseModel):\n    \"\"\" model for Barrier permeability\n\n        Args:\n            quality (str): list of quality level\n            kv (float): list of permeability values\n    \"\"\"\n    quality: Union[List[str], None] = None\n    kv: List[Union[float, int]]</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model","title":"<code>src.WellClass.libs.models.well_model</code>","text":""},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.MetaDataModel","title":"<code>MetaDataModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>meta data Args:     namespace (str): name space     name (str): can use it for project name     author (str): who made this yaml file</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class MetaDataModel(BaseModel):\n    \"\"\" meta data\n        Args:\n            namespace (str): name space\n            name (str): can use it for project name\n            author (str): who made this yaml file\n    \"\"\"\n    namespace: str = 'screen'\n    name: Union[str, None] = None\n    author: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellSpec","title":"<code>WellSpec</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>specs for standard well information Args:     well_header (WellHeaderModel): well header information     drilling (list[DrillingModel]): list of drilling information     casing_cement (list[CasingCementModel]): list of casing information     barrier (list[BarrierModel]):  list of barrier information     barrier_permeability (BarrierPermeabilityModel): list of barrier permeability     geology (list[GeologyModel]): list of geology, such as formations, information     assumptions (AssumptionsModel): misceleaneous information     co2_datum (CO2DatumModel): co2 datum</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellSpec(BaseModel):\n    \"\"\" specs for standard well information\n        Args:\n            well_header (WellHeaderModel): well header information\n            drilling (list[DrillingModel]): list of drilling information\n            casing_cement (list[CasingCementModel]): list of casing information\n            barrier (list[BarrierModel]):  list of barrier information\n            barrier_permeability (BarrierPermeabilityModel): list of barrier permeability\n            geology (list[GeologyModel]): list of geology, such as formations, information\n            assumptions (AssumptionsModel): misceleaneous information\n            co2_datum (CO2DatumModel): co2 datum \n    \"\"\"\n    well_header: WellHeaderModel\n    drilling: List[DrillingModel]\n    casing_cement: List[CasingCementModel]\n    barriers: Union[List[BarrierModel], None] = None\n    barrier_permeability: Union[BarrierPermeabilityModel, None] = None\n    geology: Union[List[GeologyModel], None] = None\n    assumptions: Union[AssumptionsModel, None] = None\n    co2_datum: Union[float, int]                                       # CO2DatumModel</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellPressureSpec","title":"<code>WellPressureSpec</code>","text":"<p>               Bases: <code>WellSpec</code></p> <p>extra specs for pressure information Args:     reservoir_pressure (ReservoirPressureModel): general reservoir pressure information     main_barrier (str): main barrier name to compute pressure</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellPressureSpec(WellSpec):\n    \"\"\" extra specs for pressure information\n        Args:\n            reservoir_pressure (ReservoirPressureModel): general reservoir pressure information\n            main_barrier (str): main barrier name to compute pressure\n    \"\"\"\n    reservoir_pressure: Union[ReservoirPressureModel, None] = None\n    main_barrier: Union[str, None] = None</code></pre>"},{"location":"code_references/well_class/models/#src.WellClass.libs.models.well_model.WellModel","title":"<code>WellModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>model including all parameters Args:     apiVersion (str): current version of this yaml format     kind (str): for GaP     metadata (MetaDataModel): miscelaneous data     spec (WellPressureSpec): well specification</p> Source code in <code>src/WellClass/libs/models/well_model.py</code> <pre><code>class WellModel(BaseModel):\n    \"\"\" model including all parameters\n        Args:\n            apiVersion (str): current version of this yaml format\n            kind (str): for GaP\n            metadata (MetaDataModel): miscelaneous data\n            spec (WellPressureSpec): well specification\n    \"\"\"\n    apiVersion: str = 'well/v0.1'\n    kind: str = 'Well'\n    metadata: Union[MetaDataModel, None] = None\n    spec: WellPressureSpec</code></pre>"},{"location":"code_references/well_class/well_class/","title":"Well class","text":""},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw","title":"<code>src.WellClass.libs.well_class.well_raw</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>)</p> <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw","title":"<code>WellRaw</code>  <code>dataclass</code>","text":"<p>Basic user input well information</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well header</p> </li> <li> <code>drilling</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>drilling well</p> </li> <li> <code>casings</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well casing</p> </li> <li> <code>barriers</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier information</p> </li> <li> <code>barrier_perm</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>barrier permeabilities</p> </li> <li> <code>geology</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gelogical formation</p> </li> <li> <code>co2_datum</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>co2 datum value</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass WellRaw:\n    \"\"\" Basic user input well information\n\n        Args:\n            header (dict): well header\n            drilling (dict): drilling well\n            casings (dict): well casing\n            barriers (dict): barrier information\n            barrier_perm (dict): barrier permeabilities\n            geology (dict): gelogical formation\n            co2_datum (float): co2 datum value\n    \"\"\"\n    header        : dict = None\n    drilling      : dict = None\n    casings       : dict = None\n    barriers      : dict = None\n    barrier_perm  : dict = None\n    geology       : dict = None\n    co2_datum     : Union[float, int] = None\n    inventory     : dict = None\n\n    def __post_init__(self):\n        \"\"\" compute basic well information\n        \"\"\"\n        self._check_inventory()\n        self._process_drilling()\n        self._process_casings()\n        self._process_barriers()\n        self._process_geology()\n\n    def _check_inventory(self):\n\n        \"\"\"\n        process to keep track of what has been declared as input.\n        \"\"\"\n        self.inventory = dict()\n\n        self.inventory['drilling'] = True\n        self.inventory['casings']  = True\n        self.inventory['barriers'] = True\n\n        if self.drilling == None:\n            print('No drilling table declared.')\n            \"\"\"\n            If no drilling table is declared, ignore the casings table as well\n            \"\"\"\n            self.inventory['drilling'] = False\n            self.inventory['casings'] = False\n\n        if self.casings == None:\n            print('No casings table declared.')\n            self.inventory['casings'] = False\n\n        if self.barriers == None:\n            print('No barriers table declared.')\n            self.inventory['barriers'] = False\n\n\n\n\n\n\n    def _process_drilling(self):\n\n        if not self.inventory['drilling']:\n            \"\"\"\n            If no drilling table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n\n            self.drilling = [{'top_rkb': _sf_depth_msl + _well_rkb, 'bottom_rkb': _well_td_rkb, 'diameter_in': 17.5, 'oh_perm': 10000}] \n\n        drilling_df = pd.DataFrame(self.drilling)\n\n        drilling_df['diameter_m'] = drilling_df['diameter_in'] * scipy.constants.inch       #0.0254\n        drilling_df['top_msl']    = drilling_df['top_rkb'] - self.header['well_rkb']\n        drilling_df['bottom_msl'] = drilling_df['bottom_rkb'] - self.header['well_rkb']\n\n        # validate drilling\n        valid_drilling(drilling_df)\n\n        self.drilling = drilling_df.to_dict()\n\n    def _process_casings(self):\n\n        if not self.inventory['casings']:\n            \"\"\"\n            If no casings table is declared, create a dummy well with info from the header\n            \"\"\"\n            _well_rkb = self.header['well_rkb']\n            _well_td_rkb = self.header['well_td_rkb']\n            _sf_depth_msl = self.header['sf_depth_msl']\n            _diameter_in = pd.DataFrame(self.drilling)['diameter_in'].min() - 2\n\n            self.casings = [{'top_rkb': _sf_depth_msl + _well_rkb,\n                             'bottom_rkb': _well_td_rkb,\n                             'diameter_in': _diameter_in,\n                             'toc_rkb': _sf_depth_msl + _well_rkb,\n                             'boc_rkb': _well_td_rkb,\n                             'shoe': True,\n                             'cb_perm': 0.05}]\n\n\n        casings_df = pd.DataFrame(self.casings)\n\n        casings_df['diameter_m'] = casings_df['diameter_in'] * scipy.constants.inch         #0.0254\n        casings_df['top_msl']    = casings_df['top_rkb']    - self.header['well_rkb']\n        casings_df['bottom_msl'] = casings_df['bottom_rkb'] - self.header['well_rkb']\n        casings_df['toc_msl']    = casings_df['toc_rkb']    - self.header['well_rkb']\n        casings_df['boc_msl']    = casings_df['boc_rkb']    - self.header['well_rkb']\n\n        # validate casings\n        valid_casings(casings_df)\n\n        self.casings = casings_df.to_dict()\n\n    def _process_barriers(self):\n\n        if self.inventory['barriers']:\n\n            barriers_df = pd.DataFrame(self.barriers)\n\n            barriers_df['top_msl']    = barriers_df['top_rkb']    - self.header['well_rkb']\n            barriers_df['bottom_msl'] = barriers_df['bottom_rkb'] - self.header['well_rkb']\n\n            # barriers_df.set_index('barrier_name', inplace=True)\n            self.barriers = barriers_df.to_dict()\n\n    def _process_geology(self):\n\n        geology_df = pd.DataFrame(self.geology)\n\n        geology_df = geology_df.dropna(how='all')\n        geology_df = geology_df.reset_index(drop=True)\n\n        geology_df['top_msl']  = geology_df['top_rkb'] - self.header['well_rkb']\n        geology_df['base_msl'] = geology_df['top_msl'] - geology_df['top_msl'].diff(periods=-1)\n        geology_df.loc[geology_df.index.max(), 'base_msl'] = self.header['well_td_rkb'] - self.header['well_rkb']\n\n        self.geology = geology_df.to_dict()\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_raw.WellRaw.__post_init__","title":"<code>__post_init__()</code>","text":"<p>compute basic well information</p> Source code in <code>src/WellClass/libs/well_class/well_raw.py</code> <pre><code>def __post_init__(self):\n    \"\"\" compute basic well information\n    \"\"\"\n    self._check_inventory()\n    self._process_drilling()\n    self._process_casings()\n    self._process_barriers()\n    self._process_geology()</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class","title":"<code>src.WellClass.libs.well_class.well_class</code>","text":"<p>How to initialize:</p> <pre><code>import well_class\n\nINDATA          = &lt;path to a csv-file with the well-data&gt;\n\n#Reads the csv-file and organize the data into a dict of dataframes\n\nwell_df         = well_class.csv_parser(INDATA)                          </code></pre> <p>Then the class is initialized with a lot of explicit calls. (Bad structure - should been done in one go: <code>mywell = Well(INDATA)</code>) <pre><code>mywell          = well_class.Well(\n                       header       = well_df['well_header'],\n                       reservoir_P  = well_df['reservoir_pressure'],\n                       drilling     = well_df['drilling'],\n                       casings      = well_df['casing_cement'],\n                       barriers     = well_df['barriers'],\n                       geology      = well_df['geology'],\n                       main_barrier = well_df['main_barrier'],\n                       barrier_perm = well_df['barrier_permeability'],\n                       co2_datum    = well_df['co2_datum']\n                   )</code></pre></p> <p>Now additional functionalities that can be explicitely called are  <pre><code>   .plot_pt()\n\n   .plot_pressure()  + plt.show()\n\n   .plot_sketch()    + plt.show()</code></pre></p>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well","title":"<code>Well</code>  <code>dataclass</code>","text":"<p>               Bases: <code>WellRaw</code></p> <p>This contains not only the basic well information but also its computed information.</p> <p>Parameters:</p> <ul> <li> <code>borehole</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>for borehole information</p> </li> <li> <code>cement_bond</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>contains information about cement bond</p> </li> <li> <code>annulus</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>gap between casing and openhole</p> </li> <li> <code>barriers_mod</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>extra information about barriers</p> </li> <li> <code>barriers_names</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>reorgainze barrier names</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass Well(WellRaw):\n    \"\"\" This contains not only the basic well information but also its computed information.\n\n        Args:\n            borehole (dict): for borehole information\n            cement_bond (dict): contains information about cement bond\n            annulus (dict): gap between casing and openhole\n            barriers_mod (dict): extra information about barriers\n            barriers_names (dict): reorgainze barrier names\n    \"\"\"\n    borehole      : dict = None\n    cement_bond   : dict = None\n    annulus       : dict = None\n    barriers_mod  : dict = None\n    barriers_names: dict = None\n\n    def __post_init__(self):\n\n        super().__post_init__()\n\n        self._compute_well()\n\n    def _compute_well(self):\n        \"\"\" compute extra well information\n        \"\"\"\n\n        self.borehole = compute_borehole(self.casings, self.drilling)\n        self.cement_bond = compute_cement_bond(self.casings, self.drilling)\n        self.annulus= compute_annulus(self.casings, self.drilling)\n\n        if self.inventory['barriers']:\n            self.barriers_mod = compute_barriers_diam(self.barriers, self.borehole)\n            self.barriers_names = get_barriers_names(self.barriers_mod)\n\n    def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n        \"\"\" Compute barrier geometrical information\n\n            Args:\n               barrier_name (str): barrier name \n        \"\"\"\n\n        # for convenience\n        barriers_mod = self.barriers_mod\n        barriers_names = self.barriers_names\n\n        # properties\n        barrier_props = {}\n\n        # height/depth\n        barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_h_d)\n\n        # radius\n        barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n        barrier_props.update(barrier_r)\n\n        return barrier_props\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_class/#src.WellClass.libs.well_class.well_class.Well.compute_barrier_props","title":"<code>compute_barrier_props(barrier_name: str) -&gt; dict</code>","text":"<p>Compute barrier geometrical information</p> <p>Parameters:</p> <ul> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier name</p> </li> </ul> Source code in <code>src/WellClass/libs/well_class/well_class.py</code> <pre><code>def compute_barrier_props(self, barrier_name: str) -&gt; dict:\n    \"\"\" Compute barrier geometrical information\n\n        Args:\n           barrier_name (str): barrier name \n    \"\"\"\n\n    # for convenience\n    barriers_mod = self.barriers_mod\n    barriers_names = self.barriers_names\n\n    # properties\n    barrier_props = {}\n\n    # height/depth\n    barrier_h_d = get_barrier_height_and_depth(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_h_d)\n\n    # radius\n    barrier_r = get_barrier_radius(barriers_mod, barriers_names, barrier_name)\n    barrier_props.update(barrier_r)\n\n    return barrier_props</code></pre>"},{"location":"code_references/well_class/well_pressure/","title":"Well pressure","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure","title":"<code>src.WellClass.libs.well_pressure.pressure</code>","text":""},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure","title":"<code>Pressure</code>  <code>dataclass</code>","text":"<p>This is used to compute leakeage rate of legacy well</p> <p>Parameters:</p> <ul> <li> <code>header</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>well header</p> </li> <li> <code>reservoir_P</code>               (<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>reservoir pressure</p> </li> <li> <code>co2_datum</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>co2 datum depth</p> </li> <li> <code>pvt_path</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>directory where PVT files are located.</p> </li> </ul> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>@dataclass              # @dataclass(kw_only=True)\nclass Pressure:\n    \"\"\" This is used to compute leakeage rate of legacy well\n\n        Args:\n            header (dict): well header\n            reservoir_P (dict): reservoir pressure\n            co2_datum (float): co2 datum depth\n            pvt_path (str): directory where PVT files are located.            \n    \"\"\"\n    header          : dict = None\n    reservoir_P     : dict = None    \n    co2_datum       : dict = None\n    pvt_path        : str  = None\n    barriers        : dict = None\n    max_pressure_pos: Union[dict, list, float, int] = None\n    pressure_scenarios : dict = None\n\n    def __post_init__(self):\n        self._check_init_pressure()\n        self._check_scenarios()\n        self._compute_CO2_pressures()\n\n\n    # TODO(hzh): non-pure function!!!\n    def _check_init_pressure(self):\n        '''\n        Calculates hydrostatic pressure at \n        reservoir_P is the entry looking something like this:\n\n        reservoir_pressure\t\t\n        depth_msl\tRP1\tRP2\n        2238\t\t        20\n\n        then P_init['depth_msl'] is the reference depth 2238\n\n        Also delta-pressures RP1 and RP2 are read and used later for leakage calculations. (self.reservoir_P[])\n\n        Note: The interpretation of the numbers set for RP1 and RP2 is a bit unclear. RP means reservoir pressure - but for the current\n              implementation it is interpreted as delta pressure: delta wrt hydrostatic pressure. \n              Initial implementation had the possibility to have absolute pressure AND a delta-pressure. But the delta-pressure had to be \n              given as a string \"+ 20\" or \"- 15\". Bit the + and - tended to create problems. \n              So alternatively one could distingwuish between RP and DP  if it is important to give in absolute pressure as well.\n              But the most interesting input IS actually the change in pressure compared with hydrostatic pressure.\n\n        '''\n        P_init = self.reservoir_P\n\n        #Get hydrostatic pressure\n        ref_z        = P_init['depth_msl']                                                  #A reference depth given in the input, e.g. top reservoir\n        hydrostaticP = get_hydrostatic_P(self.header, pvt_path=self.pvt_path)               #Calculate depth, temp(depth) hydrostatic_pressure(depth), H2ORHO(depth for hydrostatic pressure)\n\n\n        ref_p        = np.interp(ref_z, hydrostaticP['depth_msl'], hydrostaticP[ 'hs_p'])    #Hydrostatic pressure at that depth\n        print(f\"Hydrostatic pressure at reference depth {ref_z:.0f} is {ref_p:.2f}\")\n\n        self.reservoir_P['hydrostatic_pressure'] = ref_p\n\n\n        self.pressure_CO2 = hydrostaticP #store table as pressure_CO2\n\n    def _check_scenarios(self):\n\n        MAX_PRESSURE_NAME = 'max_p'\n\n        self.pressure_scenarios = {}\n\n        ref_p = self.reservoir_P['hydrostatic_pressure']\n        scenario_counter = 1\n\n        #Iterate over reservoir pressure scenarios (values under reservoir_P table)\n        for sc_name, sc_pressure in self.reservoir_P.items():\n\n            if sc_name == 'RP1':\n                if sc_pressure is None or np.isnan(sc_pressure):\n                    print(f'RP1 set as hydrostatic P = {ref_p:.2f} bar')\n                    magnitude = ref_p\n\n                else:\n                    print(f'RP1 is set as delta pressure, which yields P = {ref_p:.2f} {sc_pressure:+.2f} = {ref_p + sc_pressure:.2f} bar')\n                    magnitude = ref_p + sc_pressure\n\n\n                self.pressure_scenarios[scenario_counter] = {'name': sc_name, 'p_resrv': magnitude, 'type': 'reservoir'}\n                scenario_counter += 1\n\n            elif sc_name.startswith('RP'):\n\n\n                magnitude = sc_pressure\n\n                try:\n                    if isinstance(magnitude, str):\n                        magnitude = magnitude.replace(\" \", \"\")\n\n                    magnitude = float(magnitude)\n\n                except Exception:\n                    pass\n\n                if isinstance(magnitude, float) or isinstance(magnitude, int):\n                    # p = ref_p + RP                          #self.reservoir_P['RP1'] + RP\n                    print(f'{sc_name} is set as delta pressure, which yields P = {ref_p:.2f} {magnitude:+.2f} = {ref_p + magnitude:.2f} bar')\n                    magnitude = ref_p + magnitude\n\n                    self.pressure_scenarios[scenario_counter] = {'name': sc_name, 'p_resrv': magnitude, 'type': 'reservoir'}\n                    scenario_counter += 1\n\n                else:\n                    print(sc_name, 'ignored')\n                    continue \n\n        #Iterate over maximum pressure scenarios (values entered under max_pressure_pos)\n        if isinstance(self.max_pressure_pos, dict):   #Then max_pressure_pos is the same as barriers - and max pressure is calcualted for each barrier\n            print(f'max_pressure_pos is a dictionary of barrriers')\n            for idx, key in self.max_pressure_pos['barrier_name'].items():\n                barr_depth = self.max_pressure_pos['bottom_msl'][idx]\n                sc_name = f\"{MAX_PRESSURE_NAME}_{key}\"\n\n                self.pressure_scenarios[scenario_counter] = {'name': sc_name, 'z_MSAD': barr_depth, 'type': 'max_p'}\n                scenario_counter += 1\n\n        elif isinstance(self.max_pressure_pos, (list, float, int)):\n            print(f'max_pressure_pos is a value')\n            if isinstance(self.max_pressure_pos, (float, int)): #Make it a list with one element\n                self.max_pressure_pos = [self.max_pressure_pos]\n\n            for depth in self.max_pressure_pos:\n\n                sc_name = f\"{MAX_PRESSURE_NAME}_at_{int(depth)}\" \n                self.pressure_scenarios[scenario_counter] = {'name': sc_name, 'z_MSAD': depth, 'type': 'max_p'}\n                scenario_counter += 1\n\n    def _compute_CO2_pressures(self):\n\n        '''\n        The pressure and density for H2O and CO2  along the columns are calculated using an approximate integration\n        Hydrostatic pressure - caculatong downwards from msl\n        Pressure and density assuming a water column - starting at top reservoir and the given overpressure RP\n        Pressure and density assuming a CO2   column - starting at CO2-reference level (CO2-column could start below top reservoir) and the given overpressure RP\n        Shmin\n\n        Input:\n        max_pressure_pos is a depth from where max pressure (wrt Shmin) is calculated. It can be a dict (my_well.barriers) a list of numbers or scalars.\n                If my_well.barriers is given then it is calculated from the base of each barrier\n\n        Columns are\n            |--------------------init---------------------------------------------|---------------------RPx----------------------------------|\n            depth_msl        temp          hs_p          RHOH20            Shmin   h2o            h20_rho         co2                            RPx_co2_rho     RPx_h2o_rho_in_co2_column\n            depth below msl   temperature   hydrostatic  water density             hs_p+          densities at    Pressure given a CO2 column        Corresponding   water densitites if we are\n            depth ref for                   pressure     at hydrostatic            overpressure   RPx_h20         and overpressure RP                CO2 densities   in a CO2-column.\n            all other values                column       pressure                  RPx\n\n\n\n        ---&gt; The RP are all RP-input + hydrostatic_pressure. Hence if e.g. RP1 is hydrostatic pressure RP1-columns and hydrostatic_pressure-columns are identical.\n        '''\n\n\n        self.pressure_CO2 = _get_shmin(self.header, self.pressure_CO2)\n\n\n        #Retrieve pressure, temperature and density fields for CO2 and H2O\n        pvt_T, pvt_P, pvt_RHO_CO2, pvt_RHO_H2O =  get_pvt(self.pvt_path)\n\n        #An interpolator. Used later to look-up densities given pressure p and temperature t\n        get_rho_h2o = RectBivariateSpline(pvt_P, pvt_T, pvt_RHO_H2O)\n        get_rho_co2 = RectBivariateSpline(pvt_P, pvt_T, pvt_RHO_CO2)\n\n\n        #Define and assign a multiindex that groups columns generic for all scenarios: depth_msl, temp, hs_p, RHOH2O and Shmin \n        index_init = pd.MultiIndex.from_product([['init'], self.pressure_CO2.columns])\n        self.pressure_CO2.columns = index_init\n\n        #iterate over pressure scenarios to compute tables:\n        for press_sc in self.pressure_scenarios:\n            sc_name = self.pressure_scenarios[press_sc]['name']\n            sc_type = self.pressure_scenarios[press_sc]['type']\n\n            if sc_type == 'reservoir':\n                p_resrv = self.pressure_scenarios[press_sc]['p_resrv']\n                sc_pressure = FluidP_scenario( header = self.header,\n                                               ref_P = self.pressure_CO2['init'],\n                                               rho_H2O = get_rho_h2o,\n                                               rho_CO2 = get_rho_co2,\n                                               p_name = sc_name,\n                                               p_resrv = p_resrv,\n                                               z_resrv = self.reservoir_P['depth_msl'],\n                                               z_CO2_datum = self.co2_datum)\n\n                self.pressure_scenarios[press_sc]['p_MSAD'] = sc_pressure.p_MSAD\n                self.pressure_scenarios[press_sc]['z_MSAD'] = sc_pressure.z_MSAD\n                self.pressure_scenarios[press_sc]['z_resrv'] = sc_pressure.z_resrv\n                self.pressure_scenarios[press_sc]['p_delta'] = sc_pressure.p_delta\n\n\n\n            elif sc_type == 'max_p':\n                msad = self.pressure_scenarios[press_sc]['z_MSAD']\n\n                sc_pressure = FluidP_scenario( header = self.header,\n                                               ref_P = self.pressure_CO2['init'],\n                                               rho_H2O = get_rho_h2o,\n                                               rho_CO2 = get_rho_co2,\n                                               p_name = sc_name,\n                                               z_MSAD = msad,\n                                               z_CO2_datum = self.co2_datum)\n\n                self.pressure_scenarios[press_sc]['p_MSAD'] = sc_pressure.p_MSAD\n                self.pressure_scenarios[press_sc]['p_resrv'] = sc_pressure.p_resrv\n                self.pressure_scenarios[press_sc]['z_resrv'] = sc_pressure.z_resrv\n                self.pressure_scenarios[press_sc]['p_delta'] = sc_pressure.p_delta\n\n\n            else:\n                continue\n\n            #Drop repeated columns\n            sc_pressure.P_table = sc_pressure.P_table.drop(columns = self.pressure_CO2['init'].columns)\n\n            #Setup multiindex\n            index_table = pd.MultiIndex.from_product([[sc_name], sc_pressure.P_table.columns])\n            sc_pressure.P_table.columns = index_table\n\n            #Concatenate init table with scenario table\n            self.pressure_CO2 = pd.concat([self.pressure_CO2, sc_pressure.P_table], axis= 1)\n\n\n\n\n    def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n        \"\"\" Compute leakage rate from the given barrier\n\n            Args:\n                well (Well): well information\n                barrier_name (str): barrier to check the leakage rate\n        \"\"\"\n\n        # for convenience\n        barrier_perm = well.barrier_perm\n\n        # barrier geometries\n        barrier_props = well.compute_barrier_props(barrier_name)\n\n        # Estimate CO2 leakage in [tons/day] after a trancient period\n        barrier_leakage = compute_barrier_leakage(barrier_perm, self.pressure_scenarios, self.pressure_CO2, barrier_props)\n\n        return barrier_leakage\n\n    @property\n    def to_json(self):\n        return json.dumps(self.__dict__, indent=4)</code></pre>"},{"location":"code_references/well_class/well_pressure/#src.WellClass.libs.well_pressure.pressure.Pressure.compute_barrier_leakage","title":"<code>compute_barrier_leakage(well: Well, barrier_name: str) -&gt; pd.DataFrame</code>","text":"<p>Compute leakage rate from the given barrier</p> <p>Parameters:</p> <ul> <li> <code>well</code>               (<code>Well</code>)           \u2013            <p>well information</p> </li> <li> <code>barrier_name</code>               (<code>str</code>)           \u2013            <p>barrier to check the leakage rate</p> </li> </ul> Source code in <code>src/WellClass/libs/well_pressure/pressure.py</code> <pre><code>def compute_barrier_leakage(self, well: Well, barrier_name: str) -&gt; pd.DataFrame:\n    \"\"\" Compute leakage rate from the given barrier\n\n        Args:\n            well (Well): well information\n            barrier_name (str): barrier to check the leakage rate\n    \"\"\"\n\n    # for convenience\n    barrier_perm = well.barrier_perm\n\n    # barrier geometries\n    barrier_props = well.compute_barrier_props(barrier_name)\n\n    # Estimate CO2 leakage in [tons/day] after a trancient period\n    barrier_leakage = compute_barrier_leakage(barrier_perm, self.pressure_scenarios, self.pressure_CO2, barrier_props)\n\n    return barrier_leakage</code></pre>"}]}